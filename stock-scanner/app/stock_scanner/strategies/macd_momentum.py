"""
MACD Momentum Strategy for Backtesting (Optimized)

Entry conditions:
1. MACD histogram crosses above zero (bullish) or below zero (bearish)
2. Histogram strength >= 2x minimum threshold (strong momentum confirmation)
3. ADX > 25 (trending market - filters out ranging conditions)
4. Price structure: Higher lows (bullish) or lower highs (bearish)
5. Relative volume >= 1.2x (above-average institutional participation)
6. RSI 30-70 (not at extremes)

Stop Logic:
- 2.0x ATR from entry (wider to avoid noise-based stop-outs)

Target:
- 5.0x ATR (2.5:1 R:R)

Performance (30-day backtest):
- Original: 38.8% WR, 0.73 PF, -1003% P&L
- Optimized: 42.2% WR, 1.71 PF, +479% P&L

This strategy adapts the forex MACD momentum approach for stocks.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any
import pandas as pd
import numpy as np


@dataclass
class MACDMomentumSignal:
    """Signal generated by MACD Momentum strategy."""
    ticker: str
    signal_type: str  # 'BUY' or 'SELL'
    signal_timestamp: datetime
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    risk_reward_ratio: float
    confidence: float
    quality_tier: str

    # Technical context
    macd: float
    macd_signal: float
    macd_histogram: float
    prev_histogram: float
    rsi: float
    atr: float

    # Additional context
    sector: Optional[str] = None
    volume: Optional[int] = None
    relative_volume: Optional[float] = None

    # Compatibility with backtest order logger (optional - not used by this strategy)
    ema_20: Optional[float] = None
    ema_50: Optional[float] = None
    ema_100: Optional[float] = None
    ema_200: Optional[float] = None
    pullback_percent: Optional[float] = None


class MACDMomentumStrategy:
    """
    MACD Momentum Strategy for Backtesting

    Identifies momentum entries when MACD histogram crosses zero
    with expanding momentum and price structure confirmation.
    """

    # Risk management - wider stops to avoid noise-based stop-outs
    DEFAULT_STOP_LOSS_ATR_MULT = 2.0   # 2.0x ATR for stop
    DEFAULT_TAKE_PROFIT_ATR_MULT = 5.0  # 5x ATR for TP (2.5:1 R:R)

    # MACD thresholds
    HISTOGRAM_MIN_THRESHOLD = 0.01  # Minimum histogram value

    # ADX filter - require trending market
    DEFAULT_MIN_ADX = 25.0  # Welles Wilder threshold for strong trend

    def __init__(
        self,
        stop_loss_atr_mult: float = DEFAULT_STOP_LOSS_ATR_MULT,
        take_profit_atr_mult: float = DEFAULT_TAKE_PROFIT_ATR_MULT,
        histogram_min_threshold: float = HISTOGRAM_MIN_THRESHOLD,
        require_histogram_expansion: bool = True,
        require_price_structure: bool = True,
        structure_lookback: int = 10,
        min_rsi: float = 30.0,    # Don't enter if RSI too low (panic)
        max_rsi: float = 70.0,    # Don't enter if RSI too high (overbought)
        min_relative_volume: float = 1.2,  # Minimum relative volume (above average)
        min_adx: float = DEFAULT_MIN_ADX  # Minimum ADX for trend strength
    ):
        self.stop_loss_atr_mult = stop_loss_atr_mult
        self.take_profit_atr_mult = take_profit_atr_mult
        self.histogram_min_threshold = histogram_min_threshold
        self.require_histogram_expansion = require_histogram_expansion
        self.require_price_structure = require_price_structure
        self.structure_lookback = structure_lookback
        self.min_rsi = min_rsi
        self.max_rsi = max_rsi
        self.min_relative_volume = min_relative_volume
        self.min_adx = min_adx
        self.logger = logging.getLogger(__name__)

    def scan(
        self,
        df: pd.DataFrame,
        ticker: str,
        sector: Optional[str] = None
    ) -> Optional[MACDMomentumSignal]:
        """
        Scan data for MACD Momentum signal.

        Args:
            df: DataFrame with OHLCV and indicators (from BacktestDataProvider)
            ticker: Stock ticker symbol
            sector: Optional sector for context

        Returns:
            MACDMomentumSignal if conditions met, None otherwise
        """
        # Require at least 50 bars for indicator stability
        min_bars = 50
        if df.empty or len(df) < min_bars:
            self.logger.debug(f"{ticker}: Insufficient data ({len(df)} bars, need {min_bars})")
            return None

        # Get the most recent bars
        current = df.iloc[-1]
        previous = df.iloc[-2] if len(df) > 1 else None

        if previous is None:
            return None

        # Check if all required indicators are present
        required_cols = ['close', 'macd', 'macd_signal', 'macd_histogram', 'rsi', 'atr']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            self.logger.warning(f"{ticker}: Missing columns: {missing_cols}")
            return None

        # Check for NaN values in current bar
        if current[['macd', 'macd_signal', 'macd_histogram', 'atr']].isna().any():
            self.logger.debug(f"{ticker}: NaN values in indicators")
            return None

        # Get histogram values
        curr_histogram = float(current['macd_histogram'])
        prev_histogram = float(previous['macd_histogram'])

        # ==== DETECT HISTOGRAM ZERO CROSS ====
        # Bullish: histogram crosses from negative to positive
        bullish_cross = prev_histogram < 0 and curr_histogram > 0
        # Bearish: histogram crosses from positive to negative
        bearish_cross = prev_histogram > 0 and curr_histogram < 0

        if not bullish_cross and not bearish_cross:
            return None

        signal_type = 'BUY' if bullish_cross else 'SELL'

        # ==== HISTOGRAM DIRECTION VALIDATION (Critical Fix) ====
        # Validate that histogram direction matches the signal type
        # This prevents false signals during counter-trend bounces
        macd_line = float(current['macd'])
        signal_line = float(current['macd_signal'])

        if bullish_cross:
            # For bullish: histogram must be positive AND MACD > signal
            if curr_histogram <= 0 or macd_line <= signal_line:
                self.logger.debug(f"{ticker}: Bullish cross rejected - histogram/MACD not confirming")
                return None
        else:  # bearish_cross
            # For bearish: histogram must be negative AND MACD < signal
            if curr_histogram >= 0 or macd_line >= signal_line:
                self.logger.debug(f"{ticker}: Bearish cross rejected - histogram/MACD not confirming")
                return None

        # ==== HISTOGRAM THRESHOLD CHECK ====
        if abs(curr_histogram) < self.histogram_min_threshold:
            self.logger.debug(f"{ticker}: Histogram too weak ({curr_histogram:.4f})")
            return None

        # ==== ADX TREND STRENGTH FILTER ====
        # Only trade in trending markets - MACD fails in ranging conditions
        if pd.notna(current.get('adx')):
            adx = float(current['adx'])
            if adx < self.min_adx:
                self.logger.debug(f"{ticker}: ADX too low ({adx:.1f} < {self.min_adx})")
                return None
        else:
            # ADX is critical for momentum strategies - skip if missing
            self.logger.debug(f"{ticker}: Missing ADX data")
            return None

        # ==== HISTOGRAM EXPANSION CHECK ====
        # On zero-cross, require histogram to be strong enough to indicate conviction
        # The current histogram should be at least 2x the threshold (strong cross)
        if self.require_histogram_expansion:
            min_strong_histogram = self.histogram_min_threshold * 2.0
            if abs(curr_histogram) < min_strong_histogram:
                self.logger.debug(f"{ticker}: Histogram cross too weak ({abs(curr_histogram):.4f} < {min_strong_histogram:.4f})")
                return None

        # ==== VOLUME CHECK ====
        if pd.notna(current.get('relative_volume')):
            if current['relative_volume'] < self.min_relative_volume:
                self.logger.debug(f"{ticker}: Low volume ({current['relative_volume']:.2f}x)")
                return None

        # ==== RSI FILTER ====
        if pd.notna(current['rsi']):
            rsi = float(current['rsi'])
            if bullish_cross and rsi > self.max_rsi:
                self.logger.debug(f"{ticker}: RSI too high for buy ({rsi:.1f})")
                return None
            if bearish_cross and rsi < self.min_rsi:
                self.logger.debug(f"{ticker}: RSI too low for sell ({rsi:.1f})")
                return None

        # ==== PRICE STRUCTURE CHECK ====
        if self.require_price_structure:
            recent = df.tail(self.structure_lookback)
            if bullish_cross:
                # Check for higher lows
                if not self._has_higher_lows(recent):
                    self.logger.debug(f"{ticker}: No higher lows structure")
                    return None
            else:
                # Check for lower highs
                if not self._has_lower_highs(recent):
                    self.logger.debug(f"{ticker}: No lower highs structure")
                    return None

        # ==== CALCULATE ENTRY LEVELS ====
        entry_price = float(current['close'])
        atr = float(current['atr']) if pd.notna(current['atr']) else entry_price * 0.02

        if signal_type == 'BUY':
            stop_loss_price = entry_price - (atr * self.stop_loss_atr_mult)
            take_profit_price = entry_price + (atr * self.take_profit_atr_mult)
        else:  # SELL
            stop_loss_price = entry_price + (atr * self.stop_loss_atr_mult)
            take_profit_price = entry_price - (atr * self.take_profit_atr_mult)

        # Calculate risk/reward
        risk = abs(entry_price - stop_loss_price)
        reward = abs(take_profit_price - entry_price)
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # ==== CALCULATE CONFIDENCE ====
        confidence = self._calculate_confidence(df, current, previous, signal_type)
        quality_tier = self._get_quality_tier(confidence)

        # ==== QUALITY TIER FILTER ====
        # Skip low-quality signals
        if quality_tier in ('C', 'D'):
            self.logger.debug(f"{ticker}: Quality tier too low ({quality_tier})")
            return None

        # ==== CREATE SIGNAL ====
        signal = MACDMomentumSignal(
            ticker=ticker,
            signal_type=signal_type,
            signal_timestamp=current['timestamp'] if pd.notna(current.get('timestamp')) else datetime.now(),
            entry_price=entry_price,
            stop_loss_price=round(stop_loss_price, 4),
            take_profit_price=round(take_profit_price, 4),
            risk_reward_ratio=round(risk_reward_ratio, 2),
            confidence=round(confidence, 4),
            quality_tier=quality_tier,
            macd=round(float(current['macd']), 4),
            macd_signal=round(float(current['macd_signal']), 4),
            macd_histogram=round(curr_histogram, 4),
            prev_histogram=round(prev_histogram, 4),
            rsi=round(float(current['rsi']), 2) if pd.notna(current['rsi']) else None,
            atr=round(atr, 4),
            sector=sector,
            volume=int(current['volume']) if pd.notna(current.get('volume')) else None,
            relative_volume=round(float(current['relative_volume']), 2)
                if pd.notna(current.get('relative_volume')) else None,
            # EMA values for compatibility with backtest logger
            ema_20=round(float(current['ema_20']), 4) if pd.notna(current.get('ema_20')) else None,
            ema_50=round(float(current['ema_50']), 4) if pd.notna(current.get('ema_50')) else None,
            ema_100=round(float(current['ema_100']), 4) if pd.notna(current.get('ema_100')) else None,
            ema_200=round(float(current['ema_200']), 4) if pd.notna(current.get('ema_200')) else None,
            pullback_percent=0.0  # Not applicable for MACD strategy
        )

        self.logger.info(
            f"{ticker}: MACD {signal_type} SIGNAL - Entry: ${entry_price:.2f}, "
            f"SL: ${stop_loss_price:.2f}, TP: ${take_profit_price:.2f}, "
            f"Conf: {confidence:.1%}, Histogram: {curr_histogram:.4f}"
        )

        return signal

    def _has_higher_lows(self, df: pd.DataFrame) -> bool:
        """Check if recent price action shows higher lows (bullish structure)."""
        if len(df) < 4:
            return False

        lows = df['low'].values
        # Find local lows (simple: compare with neighbors)
        local_lows = []
        for i in range(1, len(lows) - 1):
            if lows[i] < lows[i-1] and lows[i] < lows[i+1]:
                local_lows.append(lows[i])

        if len(local_lows) < 2:
            # Not enough local lows - require clear structure
            # Fall back to checking if current low > first third of range
            min_low = min(lows)
            max_low = max(lows)
            range_low = max_low - min_low
            current_low = lows[-1]
            # Current low should be in upper 2/3 of range for bullish
            return current_low > min_low + (range_low * 0.33)

        # Check if most recent local low is higher than the one before
        return local_lows[-1] > local_lows[-2] * 0.995  # 0.5% tolerance (stricter)

    def _has_lower_highs(self, df: pd.DataFrame) -> bool:
        """Check if recent price action shows lower highs (bearish structure)."""
        if len(df) < 4:
            return False

        highs = df['high'].values
        # Find local highs
        local_highs = []
        for i in range(1, len(highs) - 1):
            if highs[i] > highs[i-1] and highs[i] > highs[i+1]:
                local_highs.append(highs[i])

        if len(local_highs) < 2:
            # Not enough local highs - require clear structure
            # Fall back to checking if current high < upper third of range
            min_high = min(highs)
            max_high = max(highs)
            range_high = max_high - min_high
            current_high = highs[-1]
            # Current high should be in lower 2/3 of range for bearish
            return current_high < max_high - (range_high * 0.33)

        # Check if most recent local high is lower than the one before
        return local_highs[-1] < local_highs[-2] * 1.005  # 0.5% tolerance (stricter)

    def _calculate_confidence(
        self,
        df: pd.DataFrame,
        current: pd.Series,
        previous: pd.Series,
        signal_type: str
    ) -> float:
        """
        Calculate confidence score for the signal.

        Factors considered:
        - Histogram strength (distance from zero)
        - Histogram acceleration (rate of change)
        - RSI position
        - Volume
        - MACD alignment
        """
        scores = []

        curr_histogram = float(current['macd_histogram'])
        prev_histogram = float(previous['macd_histogram'])

        # 1. Histogram Strength Score (0-25 points)
        # Stronger histogram = higher confidence
        hist_strength = abs(curr_histogram)
        if hist_strength >= 0.1:
            hist_score = 25
        elif hist_strength >= 0.05:
            hist_score = 20
        elif hist_strength >= 0.02:
            hist_score = 15
        else:
            hist_score = 10
        scores.append(hist_score)

        # 2. Histogram Acceleration Score (0-25 points)
        # Growing histogram = higher confidence
        hist_growth = abs(curr_histogram) - abs(prev_histogram)
        if hist_growth > 0:
            accel_score = min(25, 15 + hist_growth * 100)
        else:
            accel_score = 10
        scores.append(accel_score)

        # 3. RSI Score (0-25 points)
        # For BUY: RSI 40-60 ideal (not overbought)
        # For SELL: RSI 40-60 ideal (not oversold)
        if pd.notna(current['rsi']):
            rsi = float(current['rsi'])
            if signal_type == 'BUY':
                if 40 <= rsi <= 60:
                    rsi_score = 25
                elif 30 <= rsi < 40 or 60 < rsi <= 65:
                    rsi_score = 20
                else:
                    rsi_score = 10
            else:  # SELL
                if 40 <= rsi <= 60:
                    rsi_score = 25
                elif 35 <= rsi < 40 or 60 < rsi <= 70:
                    rsi_score = 20
                else:
                    rsi_score = 10
        else:
            rsi_score = 15
        scores.append(rsi_score)

        # 4. Volume Score (0-25 points)
        if pd.notna(current.get('relative_volume')):
            rel_vol = float(current['relative_volume'])
            if rel_vol >= 1.5:
                vol_score = 25
            elif rel_vol >= 1.2:
                vol_score = 22
            elif rel_vol >= 1.0:
                vol_score = 18
            elif rel_vol >= 0.8:
                vol_score = 15
            else:
                vol_score = 10
        else:
            vol_score = 15
        scores.append(vol_score)

        # Total confidence (0-100, normalized to 0-1)
        total_score = sum(scores)
        confidence = total_score / 100.0

        return confidence

    def _get_quality_tier(self, confidence: float) -> str:
        """Convert confidence score to quality tier."""
        if confidence >= 0.85:
            return 'A+'
        elif confidence >= 0.70:
            return 'A'
        elif confidence >= 0.60:
            return 'B'
        elif confidence >= 0.50:
            return 'C'
        else:
            return 'D'

    def get_config(self) -> Dict[str, Any]:
        """Return strategy configuration for logging."""
        return {
            'strategy_name': 'MACD_MOMENTUM',
            'stop_loss_atr_mult': self.stop_loss_atr_mult,
            'take_profit_atr_mult': self.take_profit_atr_mult,
            'histogram_min_threshold': self.histogram_min_threshold,
            'require_histogram_expansion': self.require_histogram_expansion,
            'require_price_structure': self.require_price_structure,
            'structure_lookback': self.structure_lookback,
            'min_rsi': self.min_rsi,
            'max_rsi': self.max_rsi,
            'min_relative_volume': self.min_relative_volume,
            'min_adx': self.min_adx
        }
