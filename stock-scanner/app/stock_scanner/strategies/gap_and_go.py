"""
Gap & Go Strategy for Backtesting

Identifies gap continuation plays with volume confirmation.

Entry Logic:
1. Gap up >= 2% (calculated from open vs prev close)
2. Volume surge >= 1.5x average
3. Not gapping into major resistance (overbought at 52W high)
4. Not in death cross (avoid bearish trend gaps)
5. RSI 40-80 (momentum with room to run)

Stop Logic:
- Below gap open (gap must hold)
- Max 5% stop distance

Target:
- TP1: Gap extension (75% of gap size added)
- TP2: Full gap extension or 3R

IMPORTANT: This strategy needs backtesting to determine optimal parameters.
Gaps can be high-reward but also high-risk plays.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any
import pandas as pd
import numpy as np


@dataclass
class GapSignal:
    """Signal generated by Gap & Go strategy."""
    ticker: str
    signal_type: str  # 'BUY' only
    signal_timestamp: datetime
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    risk_reward_ratio: float
    confidence: float
    quality_tier: str

    # Gap-specific context
    gap_pct: float  # Size of the gap
    gap_open_price: float  # Where the gap opened
    relative_volume: float
    atr: float

    # Additional context
    rsi: Optional[float] = None
    ema_200_above: bool = False
    is_large_gap: bool = False
    sector: Optional[str] = None


class GapAndGoStrategy:
    """
    Gap & Go Strategy for Backtesting

    Trades gap continuation when gaps show strength.
    Best for catalyst-driven moves (earnings, news).

    Key difference from other strategies:
    - Entry based on gap confirmation, not technical crossover
    - Stop below gap open (gap must hold)
    - Tighter stops due to gap risk
    """

    # Risk management - slightly wider stops
    DEFAULT_STOP_MULTIPLIER = 0.98  # Stop 2% below gap open
    DEFAULT_MAX_STOP_PCT = 5.0  # Max 5% stop

    # Gap requirements - keep original, but add better filters
    MIN_GAP_PCT = 2.0  # Minimum gap size
    LARGE_GAP_PCT = 4.0  # Large gap threshold
    MAX_GAP_PCT = 12.0  # Avoid extreme gaps

    # Volume requirements
    MIN_RELATIVE_VOLUME = 1.5  # Back to original

    # Target multipliers - larger targets
    TP1_GAP_EXTENSION = 1.0  # 100% extension of gap
    TP2_MIN_R = 2.5  # Minimum 2.5R for TP

    # Additional filters - keep but loosen
    MAX_GAP_FILL_PCT = 40.0  # Max gap fill allowed (loosened from 25)
    MIN_ADX = 18.0  # Minimum ADX (loosened from 20)

    def __init__(
        self,
        min_gap_pct: float = MIN_GAP_PCT,
        large_gap_pct: float = LARGE_GAP_PCT,
        max_gap_pct: float = MAX_GAP_PCT,
        min_relative_volume: float = MIN_RELATIVE_VOLUME,
        stop_multiplier: float = DEFAULT_STOP_MULTIPLIER,
        max_stop_pct: float = DEFAULT_MAX_STOP_PCT,
        min_rsi: float = 40.0,  # Back to original
        max_rsi: float = 75.0,  # Slightly loosened
        avoid_overbought_at_high: bool = True,
        max_gap_fill_pct: float = MAX_GAP_FILL_PCT,
        min_adx: float = MIN_ADX,
    ):
        self.min_gap_pct = min_gap_pct
        self.large_gap_pct = large_gap_pct
        self.max_gap_pct = max_gap_pct
        self.min_relative_volume = min_relative_volume
        self.stop_multiplier = stop_multiplier
        self.max_stop_pct = max_stop_pct
        self.min_rsi = min_rsi
        self.max_rsi = max_rsi
        self.avoid_overbought_at_high = avoid_overbought_at_high
        self.max_gap_fill_pct = max_gap_fill_pct
        self.min_adx = min_adx
        self.logger = logging.getLogger(__name__)

    def scan(
        self,
        df: pd.DataFrame,
        ticker: str,
        sector: Optional[str] = None
    ) -> Optional[GapSignal]:
        """
        Scan data for gap & go signal.

        Args:
            df: DataFrame with OHLCV and indicators
            ticker: Stock ticker symbol
            sector: Optional sector for context

        Returns:
            GapSignal if conditions met, None otherwise
        """
        min_bars = 50
        if df.empty or len(df) < min_bars:
            self.logger.debug(f"{ticker}: Insufficient data ({len(df)} bars)")
            return None

        # Get current and previous bars
        current = df.iloc[-1]
        previous = df.iloc[-2] if len(df) > 1 else None

        if previous is None:
            return None

        # Check required columns
        required_cols = ['open', 'close', 'high', 'low', 'atr', 'rsi', 'relative_volume']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            self.logger.warning(f"{ticker}: Missing columns: {missing_cols}")
            return None

        # ==== CALCULATE GAP ====
        prev_close = float(previous['close'])
        current_open = float(current['open'])
        current_close = float(current['close'])

        gap_pct = ((current_open - prev_close) / prev_close) * 100

        # ==== GAP SIZE CHECK ====
        if gap_pct < self.min_gap_pct:
            self.logger.debug(f"{ticker}: Gap too small ({gap_pct:.1f}%)")
            return None

        if gap_pct > self.max_gap_pct:
            self.logger.debug(f"{ticker}: Gap too large/risky ({gap_pct:.1f}%)")
            return None

        # ==== VOLUME CONFIRMATION ====
        if pd.notna(current.get('relative_volume')):
            relative_volume = float(current['relative_volume'])
            if relative_volume < self.min_relative_volume:
                self.logger.debug(f"{ticker}: Volume too low ({relative_volume:.2f}x)")
                return None
        else:
            return None  # Volume required

        # ==== GAP HOLDING CHECK ====
        # Close should be above gap open (gap held)
        if current_close < current_open:
            # Gap filled - potential reversal
            fill_pct = (current_open - current_close) / (current_open - prev_close) * 100
            if fill_pct > self.max_gap_fill_pct:  # Tightened from 50% to 25%
                self.logger.debug(f"{ticker}: Gap filled {fill_pct:.0f}%")
                return None

        # ==== ADX TREND STRENGTH FILTER ====
        if pd.notna(current.get('adx')):
            adx = float(current['adx'])
            if adx < self.min_adx:
                self.logger.debug(f"{ticker}: ADX too low ({adx:.1f})")
                return None

        # ==== RSI FILTER ====
        if pd.notna(current['rsi']):
            rsi = float(current['rsi'])
            if rsi < self.min_rsi or rsi > self.max_rsi:
                self.logger.debug(f"{ticker}: RSI out of range ({rsi:.1f})")
                return None

        # ==== AVOID OVERBOUGHT AT 52W HIGH ====
        # Check if we're at 52W high AND overbought (risky)
        if self.avoid_overbought_at_high:
            # Calculate 52W high
            lookback = min(252, len(df))
            high_52w = df.tail(lookback)['high'].max()
            pct_from_high = ((current_close - high_52w) / high_52w) * 100

            if pct_from_high > -2 and rsi > 75:  # At high and overbought
                self.logger.debug(f"{ticker}: Overbought at 52W high")
                return None

        # ==== TREND CONTEXT (EMA-200) ====
        ema_200_above = False
        if pd.notna(current.get('ema_200')):
            ema_200_above = current_close > current['ema_200']

        # ==== CALCULATE ENTRY LEVELS ====
        entry_price = current_close
        atr = float(current['atr']) if pd.notna(current['atr']) else entry_price * 0.025

        # Stop below gap open
        gap_open_price = current_open
        stop_loss_price = gap_open_price * self.stop_multiplier

        # Apply max stop constraint
        max_stop_distance = entry_price * (self.max_stop_pct / 100)
        if (entry_price - stop_loss_price) > max_stop_distance:
            stop_loss_price = entry_price - max_stop_distance
        # Ensure stop is below entry for BUY signals (avoid invalid stop-loss)
        min_stop_distance = max(entry_price * 0.002, 0.01)
        if stop_loss_price >= entry_price:
            stop_loss_price = entry_price - min_stop_distance

        # Calculate gap size in price terms
        gap_size = current_open - prev_close

        # TP1: Gap extension
        take_profit_price = entry_price + (gap_size * self.TP1_GAP_EXTENSION)

        # Ensure minimum R:R
        risk = entry_price - stop_loss_price
        min_tp = entry_price + (risk * 2.0)  # Minimum 2R
        take_profit_price = max(take_profit_price, min_tp)

        # Calculate risk/reward
        reward = take_profit_price - entry_price
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # ==== CALCULATE CONFIDENCE ====
        is_large_gap = gap_pct >= self.large_gap_pct
        confidence = self._calculate_confidence(
            gap_pct, relative_volume, rsi, ema_200_above, is_large_gap
        )
        quality_tier = self._get_quality_tier(confidence)

        # ==== CREATE SIGNAL ====
        signal = GapSignal(
            ticker=ticker,
            signal_type='BUY',
            signal_timestamp=current['timestamp'] if pd.notna(current.get('timestamp')) else datetime.now(),
            entry_price=entry_price,
            stop_loss_price=round(stop_loss_price, 4),
            take_profit_price=round(take_profit_price, 4),
            risk_reward_ratio=round(risk_reward_ratio, 2),
            confidence=round(confidence, 4),
            quality_tier=quality_tier,
            gap_pct=round(gap_pct, 2),
            gap_open_price=round(gap_open_price, 4),
            relative_volume=round(relative_volume, 2),
            atr=round(atr, 4),
            rsi=round(float(current['rsi']), 2) if pd.notna(current['rsi']) else None,
            ema_200_above=ema_200_above,
            is_large_gap=is_large_gap,
            sector=sector
        )

        self.logger.info(
            f"{ticker}: GAP SIGNAL - Entry: ${entry_price:.2f}, "
            f"SL: ${stop_loss_price:.2f}, TP: ${take_profit_price:.2f}, "
            f"Gap: +{gap_pct:.1f}%, Vol: {relative_volume:.1f}x"
        )

        return signal

    def _calculate_confidence(
        self,
        gap_pct: float,
        relative_volume: float,
        rsi: float,
        ema_200_above: bool,
        is_large_gap: bool
    ) -> float:
        """Calculate confidence score for the signal."""
        scores = []

        # 1. Gap Size Score (0-25 points)
        if gap_pct >= 6.0:
            gap_score = 25
        elif gap_pct >= 4.0:
            gap_score = 20
        elif gap_pct >= 3.0:
            gap_score = 15
        else:
            gap_score = 10
        scores.append(gap_score)

        # 2. Volume Score (0-25 points)
        if relative_volume >= 3.0:
            vol_score = 25
        elif relative_volume >= 2.0:
            vol_score = 20
        elif relative_volume >= 1.5:
            vol_score = 15
        else:
            vol_score = 10
        scores.append(vol_score)

        # 3. RSI Score (0-25 points)
        # Ideal zone: 50-70 (momentum but not overbought)
        if 50 <= rsi <= 70:
            rsi_score = 25
        elif 45 <= rsi < 50 or 70 < rsi <= 75:
            rsi_score = 18
        elif 40 <= rsi < 45 or 75 < rsi <= 80:
            rsi_score = 12
        else:
            rsi_score = 8
        scores.append(rsi_score)

        # 4. Trend Alignment Score (0-25 points)
        if ema_200_above:
            trend_score = 25  # In uptrend
        else:
            trend_score = 10  # Counter-trend gap
        scores.append(trend_score)

        # Total confidence (0-100, normalized to 0-1)
        total_score = sum(scores)
        confidence = total_score / 100.0

        return confidence

    def _get_quality_tier(self, confidence: float) -> str:
        """Convert confidence score to quality tier."""
        if confidence >= 0.85:
            return 'A+'
        elif confidence >= 0.70:
            return 'A'
        elif confidence >= 0.55:
            return 'B'
        elif confidence >= 0.40:
            return 'C'
        else:
            return 'D'

    def get_config(self) -> Dict[str, Any]:
        """Return strategy configuration for logging."""
        return {
            'strategy_name': 'GAP_AND_GO',
            'min_gap_pct': self.min_gap_pct,
            'large_gap_pct': self.large_gap_pct,
            'max_gap_pct': self.max_gap_pct,
            'min_relative_volume': self.min_relative_volume,
            'stop_multiplier': self.stop_multiplier,
            'max_stop_pct': self.max_stop_pct,
            'min_rsi': self.min_rsi,
            'max_rsi': self.max_rsi,
            'max_gap_fill_pct': self.max_gap_fill_pct,
            'min_adx': self.min_adx,
        }
