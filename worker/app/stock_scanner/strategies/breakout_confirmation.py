"""
Breakout Confirmation Strategy for Backtesting

Identifies volume-confirmed breakouts near 52-week highs.

Entry Logic:
1. Price near 52W high (within 5% or making new high)
2. Volume surge >= 1.5x average (institutional interest)
3. Price gap up or strong close (>2% daily gain)
4. Positive MACD momentum (expanding histogram)
5. ADX > 25 (trending market confirmation)
6. RSI 50-75 (momentum but not overbought)

Stop Logic:
- 2.0x ATR below entry (wider stops for breakout volatility)
- Max 8% stop distance

Target:
- 4.0x ATR (2:1 R:R)

IMPORTANT: This strategy needs backtesting to determine optimal parameters.
Current parameters are initial estimates based on scanner configuration.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any
import pandas as pd
import numpy as np


@dataclass
class BreakoutSignal:
    """Signal generated by Breakout Confirmation strategy."""
    ticker: str
    signal_type: str  # 'BUY' only (long-only for stocks)
    signal_timestamp: datetime
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    risk_reward_ratio: float
    confidence: float
    quality_tier: str

    # Breakout-specific context
    pct_from_52w_high: float  # How close to 52W high
    relative_volume: float
    daily_change_pct: float
    atr: float

    # Additional context
    rsi: Optional[float] = None
    adx: Optional[float] = None
    macd_histogram: Optional[float] = None
    has_gap_up: bool = False
    sector: Optional[str] = None


class BreakoutConfirmationStrategy:
    """
    Breakout Confirmation Strategy for Backtesting

    Identifies breakout setups near 52-week highs with volume confirmation.
    Best for momentum markets and sector leaders.

    Key difference from other strategies:
    - Focuses on new highs / near highs (less resistance overhead)
    - Requires volume surge for confirmation
    - Wider stops to handle breakout volatility
    """

    # Risk management - wider stops for breakout volatility
    DEFAULT_STOP_LOSS_ATR_MULT = 2.2   # 2.2x ATR for stop
    DEFAULT_TAKE_PROFIT_ATR_MULT = 4.5  # 4.5x ATR for TP

    # Position requirements - balanced
    MAX_PCT_FROM_52W_HIGH = 5.0  # Within 5% of high (back to original)

    # Volume requirements
    MIN_RELATIVE_VOLUME = 1.5  # Back to original
    OPTIMAL_VOLUME = 2.0  # Extra confidence bonus

    # Gap requirements
    MIN_DAILY_CHANGE = 2.0  # Back to original

    # Trend filters
    DEFAULT_MIN_ADX = 22.0  # Slightly looser than 25

    # EMA alignment filter - disabled (too strict)
    REQUIRE_EMA_ALIGNMENT = False

    def __init__(
        self,
        stop_loss_atr_mult: float = DEFAULT_STOP_LOSS_ATR_MULT,
        take_profit_atr_mult: float = DEFAULT_TAKE_PROFIT_ATR_MULT,
        max_pct_from_high: float = MAX_PCT_FROM_52W_HIGH,
        min_relative_volume: float = MIN_RELATIVE_VOLUME,
        min_daily_change: float = MIN_DAILY_CHANGE,
        min_adx: float = DEFAULT_MIN_ADX,
        min_rsi: float = 50.0,    # Back to original
        max_rsi: float = 75.0,    # Back to original
        lookback_52w: int = 252,  # ~1 year of trading days
        require_ema_alignment: bool = REQUIRE_EMA_ALIGNMENT,
    ):
        self.stop_loss_atr_mult = stop_loss_atr_mult
        self.take_profit_atr_mult = take_profit_atr_mult
        self.max_pct_from_high = max_pct_from_high
        self.min_relative_volume = min_relative_volume
        self.min_daily_change = min_daily_change
        self.min_adx = min_adx
        self.min_rsi = min_rsi
        self.max_rsi = max_rsi
        self.lookback_52w = lookback_52w
        self.require_ema_alignment = require_ema_alignment
        self.logger = logging.getLogger(__name__)

    def scan(
        self,
        df: pd.DataFrame,
        ticker: str,
        sector: Optional[str] = None
    ) -> Optional[BreakoutSignal]:
        """
        Scan data for breakout signal.

        Args:
            df: DataFrame with OHLCV and indicators (from BacktestDataProvider)
            ticker: Stock ticker symbol
            sector: Optional sector for context

        Returns:
            BreakoutSignal if conditions met, None otherwise
        """
        # Require minimum data for 52W high calculation
        min_bars = max(100, self.lookback_52w)
        if df.empty or len(df) < min_bars:
            self.logger.debug(f"{ticker}: Insufficient data ({len(df)} bars, need {min_bars})")
            return None

        # Get current bar
        current = df.iloc[-1]

        # Check required columns
        required_cols = ['close', 'high', 'atr', 'rsi', 'relative_volume']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            self.logger.warning(f"{ticker}: Missing columns: {missing_cols}")
            return None

        # ==== CALCULATE 52W HIGH ====
        lookback_data = df.tail(self.lookback_52w)
        high_52w = lookback_data['high'].max()
        current_close = float(current['close'])

        # Percentage from 52W high (negative means below high)
        pct_from_high = ((current_close - high_52w) / high_52w) * 100

        # ==== NEAR HIGH CHECK ====
        # Must be within max_pct_from_high of 52W high
        if pct_from_high < -self.max_pct_from_high:
            self.logger.debug(f"{ticker}: Too far from 52W high ({pct_from_high:.1f}%)")
            return None

        # ==== VOLUME CONFIRMATION ====
        if pd.notna(current.get('relative_volume')):
            relative_volume = float(current['relative_volume'])
            if relative_volume < self.min_relative_volume:
                self.logger.debug(f"{ticker}: Volume too low ({relative_volume:.2f}x)")
                return None
        else:
            return None  # Volume required for breakout confirmation

        # ==== PRICE ACTION CHECK ====
        # Strong close or gap up required
        prev_close = float(df.iloc[-2]['close']) if len(df) > 1 else current_close
        daily_change_pct = ((current_close - prev_close) / prev_close) * 100

        # Check for gap up
        current_open = float(current['open']) if 'open' in current else current_close
        has_gap_up = current_open > prev_close * 1.01  # 1%+ gap

        if daily_change_pct < self.min_daily_change and not has_gap_up:
            self.logger.debug(f"{ticker}: Weak price action ({daily_change_pct:.1f}%, no gap)")
            return None

        # ==== ADX TREND FILTER ====
        if pd.notna(current.get('adx')):
            adx = float(current['adx'])
            if adx < self.min_adx:
                self.logger.debug(f"{ticker}: ADX too low ({adx:.1f} < {self.min_adx})")
                return None

        # ==== EMA ALIGNMENT FILTER ====
        if self.require_ema_alignment:
            if pd.notna(current.get('ema_50')) and pd.notna(current.get('ema_200')):
                ema_50 = float(current['ema_50'])
                ema_200 = float(current['ema_200'])
                # Require Price > EMA50 > EMA200 (bullish alignment)
                if not (current_close > ema_50 > ema_200):
                    self.logger.debug(f"{ticker}: EMA not aligned (need Price > EMA50 > EMA200)")
                    return None

        # ==== RSI FILTER ====
        if pd.notna(current['rsi']):
            rsi = float(current['rsi'])
            if rsi < self.min_rsi or rsi > self.max_rsi:
                self.logger.debug(f"{ticker}: RSI out of range ({rsi:.1f})")
                return None

        # ==== MACD CONFIRMATION ====
        # Positive histogram indicates momentum
        macd_histogram = None
        if pd.notna(current.get('macd_histogram')):
            macd_histogram = float(current['macd_histogram'])
            if macd_histogram <= 0:
                self.logger.debug(f"{ticker}: MACD histogram negative")
                return None

        # ==== CALCULATE ENTRY LEVELS ====
        entry_price = current_close
        atr = float(current['atr']) if pd.notna(current['atr']) else entry_price * 0.025

        stop_loss_price = entry_price - (atr * self.stop_loss_atr_mult)

        # Max 8% stop
        max_stop = entry_price * 0.92
        stop_loss_price = max(stop_loss_price, max_stop)

        take_profit_price = entry_price + (atr * self.take_profit_atr_mult)

        # Calculate risk/reward
        risk = entry_price - stop_loss_price
        reward = take_profit_price - entry_price
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # ==== CALCULATE CONFIDENCE ====
        confidence = self._calculate_confidence(
            pct_from_high, relative_volume, daily_change_pct,
            rsi if pd.notna(current['rsi']) else 60,
            adx if pd.notna(current.get('adx')) else 25,
            has_gap_up
        )
        quality_tier = self._get_quality_tier(confidence)

        # ==== CREATE SIGNAL ====
        signal = BreakoutSignal(
            ticker=ticker,
            signal_type='BUY',
            signal_timestamp=current['timestamp'] if 'timestamp' in current else datetime.now(),
            entry_price=entry_price,
            stop_loss_price=round(stop_loss_price, 4),
            take_profit_price=round(take_profit_price, 4),
            risk_reward_ratio=round(risk_reward_ratio, 2),
            confidence=round(confidence, 4),
            quality_tier=quality_tier,
            pct_from_52w_high=round(pct_from_high, 2),
            relative_volume=round(relative_volume, 2),
            daily_change_pct=round(daily_change_pct, 2),
            atr=round(atr, 4),
            rsi=round(float(current['rsi']), 2) if pd.notna(current['rsi']) else None,
            adx=round(float(current['adx']), 2) if pd.notna(current.get('adx')) else None,
            macd_histogram=round(macd_histogram, 4) if macd_histogram else None,
            has_gap_up=has_gap_up,
            sector=sector
        )

        self.logger.info(
            f"{ticker}: BREAKOUT SIGNAL - Entry: ${entry_price:.2f}, "
            f"SL: ${stop_loss_price:.2f}, TP: ${take_profit_price:.2f}, "
            f"From High: {pct_from_high:.1f}%, Vol: {relative_volume:.1f}x"
        )

        return signal

    def _calculate_confidence(
        self,
        pct_from_high: float,
        relative_volume: float,
        daily_change_pct: float,
        rsi: float,
        adx: float,
        has_gap_up: bool
    ) -> float:
        """Calculate confidence score for the signal."""
        scores = []

        # 1. Position from High Score (0-20 points)
        # Closer to high = stronger setup
        if pct_from_high >= 0:  # New high
            position_score = 20
        elif pct_from_high >= -2:
            position_score = 18
        elif pct_from_high >= -4:
            position_score = 14
        else:
            position_score = 10
        scores.append(position_score)

        # 2. Volume Score (0-20 points)
        if relative_volume >= 3.0:
            vol_score = 20
        elif relative_volume >= 2.0:
            vol_score = 16
        elif relative_volume >= 1.5:
            vol_score = 12
        else:
            vol_score = 8
        scores.append(vol_score)

        # 3. Price Action Score (0-20 points)
        if has_gap_up and daily_change_pct >= 3.0:
            action_score = 20
        elif has_gap_up or daily_change_pct >= 3.0:
            action_score = 16
        elif daily_change_pct >= 2.0:
            action_score = 12
        else:
            action_score = 8
        scores.append(action_score)

        # 4. ADX Score (0-20 points)
        if adx >= 40:
            adx_score = 20
        elif adx >= 30:
            adx_score = 16
        elif adx >= 25:
            adx_score = 12
        else:
            adx_score = 8
        scores.append(adx_score)

        # 5. RSI Score (0-20 points)
        # Ideal zone: 55-70 (momentum but not overbought)
        if 55 <= rsi <= 70:
            rsi_score = 20
        elif 50 <= rsi < 55 or 70 < rsi <= 75:
            rsi_score = 14
        else:
            rsi_score = 10
        scores.append(rsi_score)

        # Total confidence (0-100, normalized to 0-1)
        total_score = sum(scores)
        confidence = total_score / 100.0

        return confidence

    def _get_quality_tier(self, confidence: float) -> str:
        """Convert confidence score to quality tier."""
        if confidence >= 0.85:
            return 'A+'
        elif confidence >= 0.70:
            return 'A'
        elif confidence >= 0.55:
            return 'B'
        elif confidence >= 0.40:
            return 'C'
        else:
            return 'D'

    def get_config(self) -> Dict[str, Any]:
        """Return strategy configuration for logging."""
        return {
            'strategy_name': 'BREAKOUT_CONFIRMATION',
            'stop_loss_atr_mult': self.stop_loss_atr_mult,
            'take_profit_atr_mult': self.take_profit_atr_mult,
            'max_pct_from_high': self.max_pct_from_high,
            'min_relative_volume': self.min_relative_volume,
            'min_daily_change': self.min_daily_change,
            'min_adx': self.min_adx,
            'min_rsi': self.min_rsi,
            'max_rsi': self.max_rsi,
            'require_ema_alignment': self.require_ema_alignment,
        }
