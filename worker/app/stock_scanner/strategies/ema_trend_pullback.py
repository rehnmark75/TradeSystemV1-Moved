"""
EMA Trend Pullback Strategy

Entry conditions:
1. Price > 200 EMA (long-term uptrend)
2. Price > 100 EMA (medium-term uptrend)
3. Price > 50 EMA (short-term uptrend)
4. Price dropped 2-3% below 20 EMA (pullback)
5. Price crosses back above 20 EMA (entry trigger)

This strategy identifies pullback entries in strong uptrends.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List, Dict, Any
import pandas as pd
import numpy as np


@dataclass
class PullbackSignal:
    """Signal generated by EMA Trend Pullback strategy."""
    ticker: str
    signal_type: str  # 'BUY' only for this strategy (long-only)
    signal_timestamp: datetime
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    risk_reward_ratio: float
    confidence: float
    quality_tier: str

    # Technical context
    ema_20: float
    ema_50: float
    ema_100: float
    ema_200: float
    rsi: float
    atr: float
    pullback_percent: float  # How far below EMA 20 the pullback went

    # Additional context
    sector: Optional[str] = None
    volume: Optional[int] = None
    relative_volume: Optional[float] = None


class EMATrendPullbackStrategy:
    """
    EMA Trend Pullback Strategy

    Identifies high-probability long entries when price pulls back to
    the 20 EMA in a strong uptrend (above 50, 100, and 200 EMAs).
    """

    # Strategy parameters
    DEFAULT_PULLBACK_THRESHOLD = 2.5  # 2.5% below EMA 20 (middle of 2-3% range)
    MIN_PULLBACK_THRESHOLD = 2.0      # Minimum pullback required
    MAX_PULLBACK_THRESHOLD = 5.0      # Maximum pullback (too deep = trend weakening)

    # Risk management (optimized 2025-12-25, see docs/ema_pullback_optimization_results.md)
    DEFAULT_STOP_LOSS_PCT = 5.0       # 5% stop loss
    DEFAULT_TAKE_PROFIT_PCT = 10.0    # 10% take profit (2:1 R:R)
    ATR_STOP_MULTIPLIER = 1.5         # Alternative: 1.5x ATR for stop

    def __init__(
        self,
        pullback_threshold_pct: float = DEFAULT_PULLBACK_THRESHOLD,
        stop_loss_pct: float = DEFAULT_STOP_LOSS_PCT,
        take_profit_pct: float = DEFAULT_TAKE_PROFIT_PCT,
        use_atr_stops: bool = False,
        min_rsi: float = 40.0,        # Don't enter if RSI too low (panic selling)
        max_rsi: float = 60.0,        # Don't enter if RSI too high (no real pullback)
        min_relative_volume: float = 1.2  # Minimum relative volume (20% above average)
    ):
        self.pullback_threshold_pct = pullback_threshold_pct
        self.stop_loss_pct = stop_loss_pct
        self.take_profit_pct = take_profit_pct
        self.use_atr_stops = use_atr_stops
        self.min_rsi = min_rsi
        self.max_rsi = max_rsi
        self.min_relative_volume = min_relative_volume
        self.logger = logging.getLogger(__name__)

    def scan(
        self,
        df: pd.DataFrame,
        ticker: str,
        sector: Optional[str] = None
    ) -> Optional[PullbackSignal]:
        """
        Scan data for EMA Trend Pullback signal.

        Args:
            df: DataFrame with OHLCV and indicators (from BacktestDataProvider)
            ticker: Stock ticker symbol
            sector: Optional sector for context

        Returns:
            PullbackSignal if conditions met, None otherwise
        """
        # Require at least 220 bars for 200 EMA + buffer
        min_bars = 220
        if df.empty or len(df) < min_bars:
            self.logger.debug(f"{ticker}: Insufficient data ({len(df)} bars, need {min_bars})")
            return None

        # Get the most recent bar
        current = df.iloc[-1]
        previous = df.iloc[-2] if len(df) > 1 else None

        # Check if all required indicators are present
        required_cols = ['close', 'ema_20', 'ema_50', 'ema_100', 'ema_200',
                        'rsi', 'atr', 'pct_from_ema20', 'above_ema_20', 'prev_above_ema20']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            self.logger.warning(f"{ticker}: Missing columns: {missing_cols}")
            return None

        # Check for NaN values in current bar
        if current[['ema_200', 'ema_100', 'ema_50', 'ema_20']].isna().any():
            self.logger.debug(f"{ticker}: NaN values in indicators")
            return None

        # ==== ENTRY CONDITIONS ====

        # 1. Price above 200 EMA (long-term uptrend)
        if current['close'] <= current['ema_200']:
            return None

        # 2. Price above 100 EMA (medium-term uptrend)
        if current['close'] <= current['ema_100']:
            return None

        # 3. Price above 50 EMA (short-term uptrend)
        if current['close'] <= current['ema_50']:
            return None

        # ==== ADX TREND STRENGTH FILTER ====
        # Only enter pullbacks in moderate+ trends (ADX > 20)
        # Welles Wilder's ADX: 20+ indicates trending market
        MIN_ADX = 20.0
        if pd.notna(current.get('adx')):
            if current['adx'] < MIN_ADX:
                self.logger.debug(f"{ticker}: ADX too low ({current['adx']:.1f} < {MIN_ADX})")
                return None

        # ==== MACD MOMENTUM FILTER ====
        # Only enter when MACD is positive (bullish momentum)
        if pd.notna(current.get('macd')):
            if current['macd'] <= 0:
                self.logger.debug(f"{ticker}: MACD negative ({current['macd']:.4f})")
                return None

        # 4. Price crossed ABOVE 20 EMA (entry trigger)
        if not (current['above_ema_20'] and not current['prev_above_ema20']):
            return None

        # 5. Check pullback depth - look for recent drop below EMA 20
        pullback_depth = self._find_pullback_depth(df, lookback=10)
        if pullback_depth is None:
            return None

        if pullback_depth < self.MIN_PULLBACK_THRESHOLD:
            self.logger.debug(f"{ticker}: Pullback too shallow ({pullback_depth:.2f}%)")
            return None

        if pullback_depth > self.MAX_PULLBACK_THRESHOLD:
            self.logger.debug(f"{ticker}: Pullback too deep ({pullback_depth:.2f}%)")
            return None

        # ==== ADDITIONAL FILTERS ====

        # RSI filter
        if pd.notna(current['rsi']):
            if current['rsi'] < self.min_rsi or current['rsi'] > self.max_rsi:
                self.logger.debug(f"{ticker}: RSI out of range ({current['rsi']:.1f})")
                return None

        # Volume filter
        if pd.notna(current.get('relative_volume')):
            if current['relative_volume'] < self.min_relative_volume:
                self.logger.debug(f"{ticker}: Low volume ({current['relative_volume']:.2f}x)")
                return None

        # ==== CALCULATE ENTRY LEVELS ====

        entry_price = float(current['close'])
        atr = float(current['atr']) if pd.notna(current['atr']) else entry_price * 0.02

        if self.use_atr_stops:
            stop_loss_price = entry_price - (atr * self.ATR_STOP_MULTIPLIER)
            take_profit_price = entry_price + (atr * self.ATR_STOP_MULTIPLIER * 2)
        else:
            stop_loss_price = entry_price * (1 - self.stop_loss_pct / 100)
            take_profit_price = entry_price * (1 + self.take_profit_pct / 100)

        # Calculate risk/reward
        risk = entry_price - stop_loss_price
        reward = take_profit_price - entry_price
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # ==== CALCULATE CONFIDENCE ====

        confidence = self._calculate_confidence(df, current, pullback_depth)
        quality_tier = self._get_quality_tier(confidence)

        # ==== QUALITY TIER FILTER ====
        # Skip low-quality signals (C and D tiers have negative expectancy)
        if quality_tier in ('C', 'D'):
            self.logger.debug(f"{ticker}: Quality tier too low ({quality_tier})")
            return None

        # ==== CREATE SIGNAL ====

        signal = PullbackSignal(
            ticker=ticker,
            signal_type='BUY',
            signal_timestamp=current['timestamp'] if 'timestamp' in current else datetime.now(),
            entry_price=entry_price,
            stop_loss_price=round(stop_loss_price, 4),
            take_profit_price=round(take_profit_price, 4),
            risk_reward_ratio=round(risk_reward_ratio, 2),
            confidence=round(confidence, 4),
            quality_tier=quality_tier,
            ema_20=round(float(current['ema_20']), 4),
            ema_50=round(float(current['ema_50']), 4),
            ema_100=round(float(current['ema_100']), 4),
            ema_200=round(float(current['ema_200']), 4),
            rsi=round(float(current['rsi']), 2) if pd.notna(current['rsi']) else None,
            atr=round(atr, 4),
            pullback_percent=round(pullback_depth, 4),
            sector=sector,
            volume=int(current['volume']) if pd.notna(current.get('volume')) else None,
            relative_volume=round(float(current['relative_volume']), 2)
                if pd.notna(current.get('relative_volume')) else None
        )

        self.logger.info(
            f"{ticker}: SIGNAL - Entry: ${entry_price:.2f}, "
            f"SL: ${stop_loss_price:.2f}, TP: ${take_profit_price:.2f}, "
            f"Conf: {confidence:.1%}, Pullback: {pullback_depth:.1f}%"
        )

        return signal

    def _find_pullback_depth(self, df: pd.DataFrame, lookback: int = 10) -> Optional[float]:
        """
        Find the maximum pullback depth below EMA 20 in recent bars.

        Args:
            df: DataFrame with price data
            lookback: Number of bars to look back

        Returns:
            Maximum pullback percentage below EMA 20, or None if no pullback found
        """
        recent = df.tail(lookback)

        # Find bars where price was below EMA 20
        below_ema20 = recent[recent['pct_from_ema20'] < 0]

        if below_ema20.empty:
            return None

        # Maximum pullback (most negative percentage)
        max_pullback = abs(below_ema20['pct_from_ema20'].min())

        return max_pullback

    def _calculate_confidence(
        self,
        df: pd.DataFrame,
        current: pd.Series,
        pullback_depth: float
    ) -> float:
        """
        Calculate confidence score for the signal.

        Factors considered:
        - EMA alignment strength (slope of EMAs)
        - Pullback depth (ideal is middle of range)
        - RSI position
        - Volume
        - Recent price action
        """
        scores = []

        # 1. EMA Alignment Score (0-25 points)
        # All EMAs should be sloping upward and properly stacked
        ema_score = 25.0
        if current['ema_20'] < current['ema_50']:
            ema_score -= 10
        if current['ema_50'] < current['ema_100']:
            ema_score -= 5
        if current['ema_100'] < current['ema_200']:
            ema_score -= 5
        scores.append(max(0, ema_score))

        # 2. Pullback Quality Score (0-25 points)
        # Ideal pullback is 2.5% (middle of 2-3% range)
        ideal_pullback = 2.5
        pullback_deviation = abs(pullback_depth - ideal_pullback)
        pullback_score = max(0, 25 - (pullback_deviation * 10))
        scores.append(pullback_score)

        # 3. RSI Score (0-25 points)
        # Ideal RSI is 40-60 (not overbought or oversold)
        if pd.notna(current['rsi']):
            rsi = current['rsi']
            if 40 <= rsi <= 60:
                rsi_score = 25
            elif 35 <= rsi < 40 or 60 < rsi <= 65:
                rsi_score = 20
            elif 30 <= rsi < 35 or 65 < rsi <= 70:
                rsi_score = 15
            else:
                rsi_score = 10
        else:
            rsi_score = 15  # Neutral if no RSI
        scores.append(rsi_score)

        # 4. Volume Score (0-25 points)
        if pd.notna(current.get('relative_volume')):
            rel_vol = current['relative_volume']
            if rel_vol >= 1.5:
                vol_score = 25
            elif rel_vol >= 1.0:
                vol_score = 20
            elif rel_vol >= 0.7:
                vol_score = 15
            else:
                vol_score = 10
        else:
            vol_score = 15  # Neutral if no volume data
        scores.append(vol_score)

        # Total confidence (0-100, normalized to 0-1)
        total_score = sum(scores)
        confidence = total_score / 100.0

        return confidence

    def _get_quality_tier(self, confidence: float) -> str:
        """Convert confidence score to quality tier."""
        if confidence >= 0.85:
            return 'A+'
        elif confidence >= 0.70:
            return 'A'
        elif confidence >= 0.60:
            return 'B'
        elif confidence >= 0.50:
            return 'C'
        else:
            return 'D'

    def get_config(self) -> Dict[str, Any]:
        """Return strategy configuration for logging."""
        return {
            'strategy_name': 'EMA_TREND_PULLBACK',
            'pullback_threshold_pct': self.pullback_threshold_pct,
            'stop_loss_pct': self.stop_loss_pct,
            'take_profit_pct': self.take_profit_pct,
            'use_atr_stops': self.use_atr_stops,
            'min_rsi': self.min_rsi,
            'max_rsi': self.max_rsi,
            'min_relative_volume': self.min_relative_volume
        }
