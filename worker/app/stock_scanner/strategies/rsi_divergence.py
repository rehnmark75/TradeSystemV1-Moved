"""
RSI Divergence Strategy for Backtesting

Detects bullish RSI divergence (price lower low, RSI higher low) for reversal entries.

Entry Logic:
1. Price makes lower low compared to prior swing low
2. RSI makes higher low at the same time (divergence)
3. RSI in oversold/low zone (< 50 for bullish)
4. Divergence within reasonable timeframe (5-25 bars)
5. Optional: Below EMA-200 for trend context (counter-trend play)

Stop Logic:
- Below the divergence swing low
- 1.5x ATR buffer

Target:
- TP1: 2R
- TP2: 3R (or prior swing high)

IMPORTANT: This is a counter-trend strategy - reduced position sizing recommended.
Needs backtesting to determine optimal parameters.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple
import pandas as pd
import numpy as np


@dataclass
class RSIDivergenceSignal:
    """Signal generated by RSI Divergence strategy."""
    ticker: str
    signal_type: str  # 'BUY' only for bullish divergence
    signal_timestamp: datetime
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    risk_reward_ratio: float
    confidence: float
    quality_tier: str

    # Divergence-specific context
    divergence_type: str  # 'bullish'
    rsi_current: float
    rsi_prior: float
    price_low_current: float
    price_low_prior: float
    divergence_bars: int
    atr: float

    # Additional context
    ema_200_below: bool = False
    sector: Optional[str] = None


class RSIDivergenceStrategy:
    """
    RSI Divergence Strategy for Backtesting

    Identifies bullish divergence where price makes lower low but RSI makes higher low.
    This indicates momentum is improving even as price declines - potential reversal.

    Key difference from other strategies:
    - Counter-trend play (fighting the prevailing trend)
    - Requires swing point analysis
    - More conservative position sizing
    """

    # Risk management
    DEFAULT_STOP_ATR_MULT = 1.5
    DEFAULT_TAKE_PROFIT_ATR_MULT = 3.0  # 2:1 R:R

    # Divergence detection
    RSI_PERIOD = 14
    MIN_DIVERGENCE_BARS = 5
    MAX_DIVERGENCE_BARS = 25
    SWING_WINDOW = 3  # Bars on each side to define swing

    # RSI thresholds
    BULLISH_RSI_MAX = 50.0  # RSI should be relatively low for bullish div

    def __init__(
        self,
        stop_atr_mult: float = DEFAULT_STOP_ATR_MULT,
        take_profit_atr_mult: float = DEFAULT_TAKE_PROFIT_ATR_MULT,
        min_divergence_bars: int = MIN_DIVERGENCE_BARS,
        max_divergence_bars: int = MAX_DIVERGENCE_BARS,
        swing_window: int = SWING_WINDOW,
        bullish_rsi_max: float = BULLISH_RSI_MAX,
        require_trend_context: bool = True,  # Below EMA-200 for bullish
        max_stop_pct: float = 8.0,
    ):
        self.stop_atr_mult = stop_atr_mult
        self.take_profit_atr_mult = take_profit_atr_mult
        self.min_divergence_bars = min_divergence_bars
        self.max_divergence_bars = max_divergence_bars
        self.swing_window = swing_window
        self.bullish_rsi_max = bullish_rsi_max
        self.require_trend_context = require_trend_context
        self.max_stop_pct = max_stop_pct
        self.logger = logging.getLogger(__name__)

    def scan(
        self,
        df: pd.DataFrame,
        ticker: str,
        sector: Optional[str] = None
    ) -> Optional[RSIDivergenceSignal]:
        """
        Scan data for bullish RSI divergence signal.

        Args:
            df: DataFrame with OHLCV and indicators
            ticker: Stock ticker symbol
            sector: Optional sector for context

        Returns:
            RSIDivergenceSignal if conditions met, None otherwise
        """
        min_bars = 60
        if df.empty or len(df) < min_bars:
            self.logger.debug(f"{ticker}: Insufficient data ({len(df)} bars)")
            return None

        # Check required columns
        required_cols = ['close', 'high', 'low', 'atr', 'rsi']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            self.logger.warning(f"{ticker}: Missing columns: {missing_cols}")
            return None

        # Get price arrays
        closes = df['close'].values
        highs = df['high'].values
        lows = df['low'].values
        rsi_values = df['rsi'].values

        # Detect bullish divergence
        divergence = self._detect_bullish_divergence(lows, rsi_values)

        if divergence is None:
            return None

        current_idx, prior_idx, rsi_current, rsi_prior = divergence

        # Check RSI threshold
        if rsi_current > self.bullish_rsi_max:
            self.logger.debug(f"{ticker}: RSI too high for bullish div ({rsi_current:.1f})")
            return None

        current = df.iloc[-1]

        # Check trend context if required
        ema_200_below = False
        if self.require_trend_context:
            if pd.notna(current.get('ema_200')):
                ema_200_below = current['close'] < current['ema_200']
                if not ema_200_below:
                    self.logger.debug(f"{ticker}: Not below EMA-200 for trend context")
                    return None

        # Calculate entry levels
        entry_price = float(current['close'])
        atr = float(current['atr']) if pd.notna(current['atr']) else entry_price * 0.03

        # Stop below divergence low
        divergence_low = float(lows[current_idx])
        stop_loss_price = divergence_low - (atr * self.stop_atr_mult * 0.5)

        # Apply max stop constraint
        max_stop_distance = entry_price * (self.max_stop_pct / 100)
        if (entry_price - stop_loss_price) > max_stop_distance:
            stop_loss_price = entry_price - max_stop_distance

        # Take profit
        risk = entry_price - stop_loss_price
        take_profit_price = entry_price + (risk * 2.0)  # 2R minimum

        # Calculate R:R
        reward = take_profit_price - entry_price
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # Calculate confidence
        divergence_bars = current_idx - prior_idx
        confidence = self._calculate_confidence(
            rsi_current, rsi_prior, divergence_bars, ema_200_below
        )
        quality_tier = self._get_quality_tier(confidence)

        # Create signal
        signal = RSIDivergenceSignal(
            ticker=ticker,
            signal_type='BUY',
            signal_timestamp=current['timestamp'] if 'timestamp' in current else datetime.now(),
            entry_price=entry_price,
            stop_loss_price=round(stop_loss_price, 4),
            take_profit_price=round(take_profit_price, 4),
            risk_reward_ratio=round(risk_reward_ratio, 2),
            confidence=round(confidence, 4),
            quality_tier=quality_tier,
            divergence_type='bullish',
            rsi_current=round(rsi_current, 2),
            rsi_prior=round(rsi_prior, 2),
            price_low_current=round(divergence_low, 4),
            price_low_prior=round(float(lows[prior_idx]), 4),
            divergence_bars=divergence_bars,
            atr=round(atr, 4),
            ema_200_below=ema_200_below,
            sector=sector
        )

        self.logger.info(
            f"{ticker}: RSI DIVERGENCE SIGNAL - Entry: ${entry_price:.2f}, "
            f"SL: ${stop_loss_price:.2f}, RSI: {rsi_prior:.0f} -> {rsi_current:.0f}"
        )

        return signal

    def _detect_bullish_divergence(
        self,
        lows: np.ndarray,
        rsi_values: np.ndarray
    ) -> Optional[Tuple[int, int, float, float]]:
        """
        Detect bullish RSI divergence.

        Bullish: Price makes lower low, RSI makes higher low.

        Returns:
            Tuple of (current_idx, prior_idx, rsi_current, rsi_prior) if found
        """
        # Find swing lows
        swing_lows = self._find_swing_lows(lows)

        if len(swing_lows) < 2:
            return None

        # Check recent swing lows for divergence (look back max 5 recent swings)
        recent_swings = swing_lows[-5:] if len(swing_lows) >= 5 else swing_lows

        for i in range(len(recent_swings) - 1, 0, -1):
            current_idx = recent_swings[i]
            prior_idx = recent_swings[i - 1]

            # Must be recent (within setup window)
            if len(lows) - current_idx > 5:
                continue

            # Check bar distance constraints
            bar_diff = current_idx - prior_idx
            if bar_diff < self.min_divergence_bars or bar_diff > self.max_divergence_bars:
                continue

            # Check for lower low in price
            if lows[current_idx] >= lows[prior_idx]:
                continue  # Not a lower low

            # Check for higher low in RSI
            rsi_current = rsi_values[current_idx]
            rsi_prior = rsi_values[prior_idx]

            if np.isnan(rsi_current) or np.isnan(rsi_prior):
                continue

            if rsi_current <= rsi_prior:
                continue  # Not a higher RSI low

            # Bullish divergence found!
            return (current_idx, prior_idx, float(rsi_current), float(rsi_prior))

        return None

    def _find_swing_lows(self, lows: np.ndarray) -> List[int]:
        """Find swing low indices in price data."""
        swing_lows = []
        window = self.swing_window

        for i in range(window, len(lows) - window):
            is_low = True
            for j in range(1, window + 1):
                if lows[i] > lows[i - j] or lows[i] > lows[i + j]:
                    is_low = False
                    break
            if is_low:
                swing_lows.append(i)

        return swing_lows

    def _calculate_confidence(
        self,
        rsi_current: float,
        rsi_prior: float,
        divergence_bars: int,
        ema_200_below: bool
    ) -> float:
        """Calculate confidence score for the signal."""
        scores = []

        # 1. RSI Level Score (0-25 points)
        # Lower RSI = stronger oversold condition
        if rsi_current <= 25:
            rsi_score = 25
        elif rsi_current <= 30:
            rsi_score = 22
        elif rsi_current <= 35:
            rsi_score = 18
        elif rsi_current <= 40:
            rsi_score = 14
        else:
            rsi_score = 10
        scores.append(rsi_score)

        # 2. RSI Improvement Score (0-25 points)
        # How much did RSI improve while price made lower low
        rsi_improvement = rsi_current - rsi_prior
        if rsi_improvement >= 15:
            improvement_score = 25
        elif rsi_improvement >= 10:
            improvement_score = 20
        elif rsi_improvement >= 5:
            improvement_score = 15
        else:
            improvement_score = 10
        scores.append(improvement_score)

        # 3. Divergence Duration Score (0-25 points)
        # 10-20 bars is ideal
        if 10 <= divergence_bars <= 20:
            duration_score = 25
        elif 8 <= divergence_bars < 10 or 20 < divergence_bars <= 23:
            duration_score = 18
        else:
            duration_score = 12
        scores.append(duration_score)

        # 4. Trend Context Score (0-25 points)
        if ema_200_below:
            trend_score = 25  # Counter-trend in downtrend = ideal setup
        else:
            trend_score = 10  # Less ideal without trend context
        scores.append(trend_score)

        # Total confidence
        total_score = sum(scores)
        confidence = total_score / 100.0

        return confidence

    def _get_quality_tier(self, confidence: float) -> str:
        """Convert confidence score to quality tier."""
        if confidence >= 0.85:
            return 'A+'
        elif confidence >= 0.70:
            return 'A'
        elif confidence >= 0.55:
            return 'B'
        elif confidence >= 0.40:
            return 'C'
        else:
            return 'D'

    def get_config(self) -> Dict[str, Any]:
        """Return strategy configuration for logging."""
        return {
            'strategy_name': 'RSI_DIVERGENCE',
            'stop_atr_mult': self.stop_atr_mult,
            'take_profit_atr_mult': self.take_profit_atr_mult,
            'min_divergence_bars': self.min_divergence_bars,
            'max_divergence_bars': self.max_divergence_bars,
            'swing_window': self.swing_window,
            'bullish_rsi_max': self.bullish_rsi_max,
            'require_trend_context': self.require_trend_context,
            'max_stop_pct': self.max_stop_pct,
        }
