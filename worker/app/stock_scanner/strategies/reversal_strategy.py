"""
Reversal Strategy for Backtesting (Unified: Climax + Mean Reversion + Wyckoff Spring)

Combines three reversal detection methods for comprehensive bottom-finding.

Detection Methods:
1. SELLING CLIMAX: New low + volume spike + reversal close
2. MEAN REVERSION: RSI oversold + bullish candlestick pattern
3. WYCKOFF SPRING: Consolidation box + support break + recovery

Entry Logic:
- Any of the above patterns detected
- Multi-pattern confluence adds confidence
- Counter-trend entry with strict risk management

Stop Logic:
- Below pattern low (climax/spring/swing low)
- 1.5-2x ATR buffer

Target:
- TP1: 2R
- TP2: 3R

IMPORTANT: Counter-trend strategy - reduced position sizing recommended.
Needs backtesting to determine optimal parameters.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple
from enum import Enum
import pandas as pd
import numpy as np


class ReversalPatternType(Enum):
    """Type of reversal pattern detected."""
    SELLING_CLIMAX = "selling_climax"
    MEAN_REVERSION = "mean_reversion"
    WYCKOFF_SPRING = "wyckoff_spring"


@dataclass
class ReversalSignal:
    """Signal generated by Reversal strategy."""
    ticker: str
    signal_type: str  # 'BUY' only
    signal_timestamp: datetime
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    risk_reward_ratio: float
    confidence: float
    quality_tier: str

    # Reversal-specific context
    patterns_detected: List[str]  # List of pattern types found
    primary_pattern: str  # Main pattern
    pattern_count: int  # Number of patterns (confluence)
    atr: float

    # Pattern-specific data
    rsi: Optional[float] = None
    volume_ratio: Optional[float] = None
    close_position: Optional[float] = None  # 0-1, position in day's range
    sector: Optional[str] = None


class ReversalStrategy:
    """
    Unified Reversal Strategy for Backtesting

    Combines selling climax, mean reversion, and Wyckoff spring detection
    into a single strategy for comprehensive reversal identification.

    Key difference from other strategies:
    - Multiple reversal detection methods
    - Confluence bonus when multiple patterns align
    - Counter-trend - requires strict risk management
    """

    # Risk management - tighter stops, larger targets
    DEFAULT_STOP_ATR_MULT = 1.5  # Tighter stop (was 1.8)
    DEFAULT_TAKE_PROFIT_RR = 2.5  # Higher R:R target (was 2.0)

    # Selling Climax parameters - stricter
    CLIMAX_NEW_LOW_LOOKBACK = 20
    CLIMAX_VOLUME_SPIKE_MULT = 3.0  # Higher volume requirement (was 2.5)
    CLIMAX_MIN_CLOSE_POSITION = 0.6  # Stronger reversal close (was 0.5)

    # Mean Reversion parameters - stricter RSI
    MEAN_REV_MAX_RSI = 30.0  # True oversold only (was 35)
    MEAN_REV_EXTREME_RSI = 22.0  # More extreme (was 25)

    # Wyckoff Spring parameters - tighter
    SPRING_BOX_LOOKBACK = 20
    SPRING_MAX_BOX_HEIGHT_PCT = 8.0  # Tighter consolidation (was 10)
    SPRING_MIN_BOX_HEIGHT_PCT = 2.0
    SPRING_MAX_VOLUME_RATIO = 1.0  # Lower volume on spring (was 1.2)

    # Quality filter - B-tier and above only
    MIN_CONFIDENCE_THRESHOLD = 0.58

    def __init__(
        self,
        stop_atr_mult: float = DEFAULT_STOP_ATR_MULT,
        take_profit_rr: float = DEFAULT_TAKE_PROFIT_RR,
        climax_volume_mult: float = CLIMAX_VOLUME_SPIKE_MULT,
        mean_rev_max_rsi: float = MEAN_REV_MAX_RSI,
        max_stop_pct: float = 8.0,
        min_confidence: float = MIN_CONFIDENCE_THRESHOLD,
    ):
        self.stop_atr_mult = stop_atr_mult
        self.take_profit_rr = take_profit_rr
        self.climax_volume_mult = climax_volume_mult
        self.mean_rev_max_rsi = mean_rev_max_rsi
        self.max_stop_pct = max_stop_pct
        self.min_confidence = min_confidence
        self.logger = logging.getLogger(__name__)

    def scan(
        self,
        df: pd.DataFrame,
        ticker: str,
        sector: Optional[str] = None
    ) -> Optional[ReversalSignal]:
        """
        Scan data for any reversal pattern.

        Args:
            df: DataFrame with OHLCV and indicators
            ticker: Stock ticker symbol
            sector: Optional sector for context

        Returns:
            ReversalSignal if any pattern detected, None otherwise
        """
        min_bars = max(self.CLIMAX_NEW_LOW_LOOKBACK, self.SPRING_BOX_LOOKBACK) + 10
        if df.empty or len(df) < min_bars:
            self.logger.debug(f"{ticker}: Insufficient data ({len(df)} bars)")
            return None

        # Check required columns
        required_cols = ['close', 'high', 'low', 'volume', 'atr', 'rsi']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            self.logger.warning(f"{ticker}: Missing columns: {missing_cols}")
            return None

        # Get arrays
        closes = df['close'].values
        highs = df['high'].values
        lows = df['low'].values
        volumes = df['volume'].values

        current = df.iloc[-1]

        # Detect all patterns
        patterns_found = []
        pattern_data = {}

        # 1. Check Selling Climax
        climax = self._detect_selling_climax(closes, highs, lows, volumes)
        if climax:
            patterns_found.append(ReversalPatternType.SELLING_CLIMAX)
            pattern_data['climax'] = climax

        # 2. Check Mean Reversion (RSI Oversold)
        mean_rev = self._check_mean_reversion(current)
        if mean_rev:
            patterns_found.append(ReversalPatternType.MEAN_REVERSION)
            pattern_data['mean_rev'] = mean_rev

        # 3. Check Wyckoff Spring
        spring = self._detect_wyckoff_spring(closes, highs, lows, volumes)
        if spring:
            patterns_found.append(ReversalPatternType.WYCKOFF_SPRING)
            pattern_data['spring'] = spring

        # No patterns found
        if not patterns_found:
            return None

        # Determine primary pattern (prefer climax > spring > mean_rev)
        if ReversalPatternType.SELLING_CLIMAX in patterns_found:
            primary = ReversalPatternType.SELLING_CLIMAX
        elif ReversalPatternType.WYCKOFF_SPRING in patterns_found:
            primary = ReversalPatternType.WYCKOFF_SPRING
        else:
            primary = ReversalPatternType.MEAN_REVERSION

        # Calculate entry levels
        entry_price = float(current['close'])
        atr = float(current['atr']) if pd.notna(current['atr']) else entry_price * 0.03

        # Stop based on primary pattern
        stop_loss_price = self._calculate_stop(
            primary, pattern_data, entry_price, atr, lows
        )

        # Apply max stop
        max_stop_distance = entry_price * (self.max_stop_pct / 100)
        if (entry_price - stop_loss_price) > max_stop_distance:
            stop_loss_price = entry_price - max_stop_distance

        # Take profit
        risk = entry_price - stop_loss_price
        take_profit_price = entry_price + (risk * self.take_profit_rr)

        # R:R
        reward = take_profit_price - entry_price
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # Calculate confidence
        rsi = float(current['rsi']) if pd.notna(current['rsi']) else 50
        volume_ratio = float(current['relative_volume']) if pd.notna(current.get('relative_volume')) else 1.0

        confidence = self._calculate_confidence(
            patterns_found, pattern_data, rsi, volume_ratio
        )

        # Filter out low-confidence signals (C-tier and below)
        if confidence < self.min_confidence:
            self.logger.debug(f"{ticker}: Confidence too low ({confidence:.2f} < {self.min_confidence})")
            return None

        quality_tier = self._get_quality_tier(confidence)

        # Get close position if available
        close_position = None
        if primary == ReversalPatternType.SELLING_CLIMAX and 'climax' in pattern_data:
            close_position = pattern_data['climax'][1]  # close_position from tuple
        elif primary == ReversalPatternType.WYCKOFF_SPRING and 'spring' in pattern_data:
            close_position = pattern_data['spring'][3]  # close_position from tuple

        # Create signal
        signal = ReversalSignal(
            ticker=ticker,
            signal_type='BUY',
            signal_timestamp=current['timestamp'] if pd.notna(current.get('timestamp')) else datetime.now(),
            entry_price=entry_price,
            stop_loss_price=round(stop_loss_price, 4),
            take_profit_price=round(take_profit_price, 4),
            risk_reward_ratio=round(risk_reward_ratio, 2),
            confidence=round(confidence, 4),
            quality_tier=quality_tier,
            patterns_detected=[p.value for p in patterns_found],
            primary_pattern=primary.value,
            pattern_count=len(patterns_found),
            atr=round(atr, 4),
            rsi=round(rsi, 2),
            volume_ratio=round(volume_ratio, 2),
            close_position=round(close_position, 2) if close_position else None,
            sector=sector
        )

        self.logger.info(
            f"{ticker}: REVERSAL SIGNAL ({primary.value}) - Entry: ${entry_price:.2f}, "
            f"Patterns: {len(patterns_found)}, RSI: {rsi:.0f}"
        )

        return signal

    def _detect_selling_climax(
        self,
        closes: np.ndarray,
        highs: np.ndarray,
        lows: np.ndarray,
        volumes: np.ndarray
    ) -> Optional[Tuple[int, float]]:
        """Detect selling climax pattern."""
        lookback = self.CLIMAX_NEW_LOW_LOOKBACK
        vol_period = 20

        if len(closes) < lookback + vol_period:
            return None

        # Check last 3 days
        for i in range(len(closes) - 3, len(closes)):
            if i < lookback + vol_period:
                continue

            # 1. New low
            prior_lows = lows[i - lookback:i]
            if lows[i] >= min(prior_lows):
                continue

            # 2. Volume spike
            avg_volume = np.mean(volumes[i - vol_period:i])
            if volumes[i] < avg_volume * self.climax_volume_mult:
                continue

            # 3. Reversal close
            day_range = highs[i] - lows[i]
            if day_range <= 0:
                continue

            close_position = (closes[i] - lows[i]) / day_range
            if close_position < self.CLIMAX_MIN_CLOSE_POSITION:
                continue

            return (i, close_position)

        return None

    def _check_mean_reversion(self, current: pd.Series) -> Optional[Dict[str, Any]]:
        """Check mean reversion conditions."""
        if pd.isna(current['rsi']):
            return None

        rsi = float(current['rsi'])

        if rsi > self.mean_rev_max_rsi:
            return None

        return {
            'rsi': rsi,
            'extreme_oversold': rsi <= self.MEAN_REV_EXTREME_RSI
        }

    def _detect_wyckoff_spring(
        self,
        closes: np.ndarray,
        highs: np.ndarray,
        lows: np.ndarray,
        volumes: np.ndarray
    ) -> Optional[Tuple[int, float, float, float, float]]:
        """Detect Wyckoff spring pattern."""
        box_lookback = self.SPRING_BOX_LOOKBACK
        vol_period = 20

        if len(closes) < box_lookback + vol_period:
            return None

        # Check last 3 days
        for i in range(len(closes) - 3, len(closes)):
            if i < box_lookback + vol_period:
                continue

            # 1. Calculate consolidation box
            box_start = i - box_lookback
            box_end = i - 1

            box_highs = highs[box_start:box_end]
            box_lows = lows[box_start:box_end]

            support = np.min(box_lows)
            resistance = np.max(box_highs)

            # 2. Check box tightness
            if support <= 0:
                continue

            box_height_pct = ((resistance - support) / support) * 100
            if box_height_pct > self.SPRING_MAX_BOX_HEIGHT_PCT:
                continue
            if box_height_pct < self.SPRING_MIN_BOX_HEIGHT_PCT:
                continue

            # 3. Spring: low below support, close recovers
            if lows[i] >= support:
                continue
            if closes[i] <= support:
                continue

            # 4. Close in upper portion
            day_range = highs[i] - lows[i]
            if day_range <= 0:
                continue

            close_position = (closes[i] - lows[i]) / day_range
            if close_position < 0.5:
                continue

            # 5. Light volume
            avg_volume = np.mean(volumes[i - vol_period:i])
            if avg_volume <= 0:
                continue

            volume_ratio = volumes[i] / avg_volume
            if volume_ratio > self.SPRING_MAX_VOLUME_RATIO:
                continue

            return (i, support, resistance, close_position, volume_ratio)

        return None

    def _calculate_stop(
        self,
        primary: ReversalPatternType,
        pattern_data: Dict,
        entry_price: float,
        atr: float,
        lows: np.ndarray
    ) -> float:
        """Calculate stop loss based on primary pattern."""

        if primary == ReversalPatternType.SELLING_CLIMAX:
            climax = pattern_data.get('climax')
            if climax:
                climax_idx = climax[0]
                return float(lows[climax_idx]) - (atr * 0.5)

        elif primary == ReversalPatternType.WYCKOFF_SPRING:
            spring = pattern_data.get('spring')
            if spring:
                spring_idx = spring[0]
                return float(lows[spring_idx]) - (atr * 0.5)

        # Default: ATR-based stop
        return entry_price - (atr * self.stop_atr_mult)

    def _calculate_confidence(
        self,
        patterns: List[ReversalPatternType],
        pattern_data: Dict,
        rsi: float,
        volume_ratio: float
    ) -> float:
        """Calculate confidence score."""
        scores = []

        # 1. Pattern Count Score (0-30 points)
        pattern_count = len(patterns)
        if pattern_count >= 3:
            count_score = 30
        elif pattern_count >= 2:
            count_score = 22
        else:
            count_score = 12
        scores.append(count_score)

        # 2. RSI Score (0-25 points)
        if rsi <= 25:
            rsi_score = 25
        elif rsi <= 30:
            rsi_score = 22
        elif rsi <= 35:
            rsi_score = 18
        else:
            rsi_score = 12
        scores.append(rsi_score)

        # 3. Volume Score (0-25 points)
        if volume_ratio >= 3.0:
            vol_score = 25
        elif volume_ratio >= 2.0:
            vol_score = 20
        elif volume_ratio >= 1.5:
            vol_score = 15
        else:
            vol_score = 10
        scores.append(vol_score)

        # 4. Pattern Quality Score (0-20 points)
        quality_score = 10  # Base

        # Climax close position bonus
        if 'climax' in pattern_data:
            close_pos = pattern_data['climax'][1]
            if close_pos >= 0.7:
                quality_score += 5

        # Spring low volume bonus
        if 'spring' in pattern_data:
            spring_vol = pattern_data['spring'][4]
            if spring_vol <= 0.8:
                quality_score += 5

        scores.append(min(quality_score, 20))

        # Total confidence
        total_score = sum(scores)
        confidence = total_score / 100.0

        return confidence

    def _get_quality_tier(self, confidence: float) -> str:
        """Convert confidence score to quality tier."""
        if confidence >= 0.85:
            return 'A+'
        elif confidence >= 0.70:
            return 'A'
        elif confidence >= 0.55:
            return 'B'
        elif confidence >= 0.40:
            return 'C'
        else:
            return 'D'

    def get_config(self) -> Dict[str, Any]:
        """Return strategy configuration for logging."""
        return {
            'strategy_name': 'REVERSAL',
            'stop_atr_mult': self.stop_atr_mult,
            'take_profit_rr': self.take_profit_rr,
            'climax_volume_mult': self.climax_volume_mult,
            'mean_rev_max_rsi': self.mean_rev_max_rsi,
            'max_stop_pct': self.max_stop_pct,
            'min_confidence': self.min_confidence,
        }
