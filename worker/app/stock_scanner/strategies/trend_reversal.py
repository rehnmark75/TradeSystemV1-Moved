"""
Trend Reversal Strategy for Backtesting

Identifies stocks transitioning from downtrend to uptrend with multi-day confirmation.

Entry Logic:
1. Prior Downtrend: RSI was below 40, price below EMA-20 in prior period
2. Multi-Day Recovery: At least 2 of last 3 days positive
3. RSI Improvement: RSI improved by 10+ points from the low
4. MACD Improving: Histogram trending up or turning positive
5. Current RSI: In 40-65 range (recovered but not overbought)

Stop Logic:
- 2.5x ATR below entry (wider for reversal plays)

Target:
- TP1: 2R
- TP2: 3R

IMPORTANT: This strategy catches trend changes early.
Needs backtesting to optimize confirmation criteria.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any
import pandas as pd
import numpy as np


@dataclass
class TrendReversalSignal:
    """Signal generated by Trend Reversal strategy."""
    ticker: str
    signal_type: str  # 'BUY' only
    signal_timestamp: datetime
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    risk_reward_ratio: float
    confidence: float
    quality_tier: str

    # Reversal-specific context
    positive_days: int  # Out of confirmation window
    rsi_improvement: float  # RSI change from low
    rsi_low: float  # Lowest RSI during downtrend
    rsi_current: float
    macd_improving: bool
    atr: float

    # Additional context
    crossed_ema_20: bool = False
    sector: Optional[str] = None


class TrendReversalStrategy:
    """
    Trend Reversal Strategy for Backtesting

    Detects downtrend-to-uptrend transitions with multi-day confirmation.
    Different from mean reversion - this is actual trend change, not bounce.

    Key difference from other strategies:
    - Looks for actual trend change, not just oversold bounce
    - Requires multi-day confirmation (not single candle)
    - Entry early in potential new uptrend
    """

    # Risk management - best from v2
    DEFAULT_STOP_ATR_MULT = 2.0  # Balanced stop
    DEFAULT_TAKE_PROFIT_RR = 2.5  # Good R:R

    # Prior downtrend requirements
    RSI_WAS_OVERSOLD_THRESHOLD = 35.0  # Deep oversold
    PRICE_BELOW_EMA20_PCT = -3.0  # 3% below EMA-20

    # Confirmation requirements
    CONFIRMATION_DAYS = 3
    MIN_POSITIVE_DAYS = 2  # At least 2 of 3 days
    MIN_RSI_IMPROVEMENT = 12.0  # Good improvement

    # Current state requirements
    RSI_NOW_MIN = 45.0  # Recovery zone
    RSI_NOW_MAX = 60.0  # Has room
    RSI_NOT_EXTENDED = 65.0

    # Quality filter - B-tier and above
    MIN_CONFIDENCE_THRESHOLD = 0.55

    # No MACD requirement (didn't help)
    REQUIRE_MACD_IMPROVING = False

    def __init__(
        self,
        stop_atr_mult: float = DEFAULT_STOP_ATR_MULT,
        take_profit_rr: float = DEFAULT_TAKE_PROFIT_RR,
        confirmation_days: int = CONFIRMATION_DAYS,
        min_positive_days: int = MIN_POSITIVE_DAYS,
        min_rsi_improvement: float = MIN_RSI_IMPROVEMENT,
        rsi_now_min: float = RSI_NOW_MIN,
        rsi_now_max: float = RSI_NOW_MAX,
        min_confidence: float = MIN_CONFIDENCE_THRESHOLD,
        require_macd_improving: bool = REQUIRE_MACD_IMPROVING,
    ):
        self.stop_atr_mult = stop_atr_mult
        self.take_profit_rr = take_profit_rr
        self.confirmation_days = confirmation_days
        self.min_positive_days = min_positive_days
        self.min_rsi_improvement = min_rsi_improvement
        self.rsi_now_min = rsi_now_min
        self.rsi_now_max = rsi_now_max
        self.min_confidence = min_confidence
        self.require_macd_improving = require_macd_improving
        self.logger = logging.getLogger(__name__)

    def scan(
        self,
        df: pd.DataFrame,
        ticker: str,
        sector: Optional[str] = None
    ) -> Optional[TrendReversalSignal]:
        """
        Scan data for trend reversal signal.

        Args:
            df: DataFrame with OHLCV and indicators
            ticker: Stock ticker symbol
            sector: Optional sector for context

        Returns:
            TrendReversalSignal if conditions met, None otherwise
        """
        # Need enough history for confirmation + downtrend check
        min_bars = self.confirmation_days + 10
        if df.empty or len(df) < min_bars:
            self.logger.debug(f"{ticker}: Insufficient data ({len(df)} bars)")
            return None

        # Check required columns
        required_cols = ['close', 'open', 'atr', 'rsi', 'ema_20', 'macd_histogram']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            self.logger.warning(f"{ticker}: Missing columns: {missing_cols}")
            return None

        current = df.iloc[-1]

        # ==== CURRENT STATE CHECK ====
        if pd.isna(current['rsi']):
            return None

        rsi_current = float(current['rsi'])

        # RSI in recovery zone
        if rsi_current < self.rsi_now_min or rsi_current > self.rsi_now_max:
            self.logger.debug(f"{ticker}: RSI not in recovery zone ({rsi_current:.1f})")
            return None

        # ==== CHECK PRIOR DOWNTREND ====
        prior_period = df.iloc[-(self.confirmation_days + 5):-self.confirmation_days]
        was_in_downtrend, rsi_low = self._check_prior_downtrend(prior_period)

        if not was_in_downtrend:
            self.logger.debug(f"{ticker}: No prior downtrend detected")
            return None

        # ==== CHECK MULTI-DAY CONFIRMATION ====
        confirmation_period = df.iloc[-self.confirmation_days:]
        reversal_metrics = self._calculate_reversal_metrics(confirmation_period, rsi_low)

        if not self._passes_reversal_criteria(reversal_metrics):
            self.logger.debug(f"{ticker}: Failed reversal criteria")
            return None

        # ==== CALCULATE ENTRY LEVELS ====
        entry_price = float(current['close'])
        atr = float(current['atr']) if pd.notna(current['atr']) else entry_price * 0.03

        stop_loss_price = entry_price - (atr * self.stop_atr_mult)
        risk = entry_price - stop_loss_price
        take_profit_price = entry_price + (risk * self.take_profit_rr)

        # R:R
        reward = take_profit_price - entry_price
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # Check if crossed above EMA-20
        crossed_ema_20 = False
        if pd.notna(current.get('ema_20')):
            crossed_ema_20 = entry_price > current['ema_20']
            # Check if it was below in prior period
            if len(prior_period) > 0 and pd.notna(prior_period.iloc[-1].get('ema_20')):
                was_below = prior_period.iloc[-1]['close'] < prior_period.iloc[-1]['ema_20']
                crossed_ema_20 = crossed_ema_20 and was_below

        # Calculate confidence
        confidence = self._calculate_confidence(
            reversal_metrics, rsi_low, crossed_ema_20
        )

        # Filter out low-confidence signals
        if confidence < self.min_confidence:
            self.logger.debug(f"{ticker}: Confidence too low ({confidence:.2f} < {self.min_confidence})")
            return None

        quality_tier = self._get_quality_tier(confidence)

        # Create signal
        signal = TrendReversalSignal(
            ticker=ticker,
            signal_type='BUY',
            signal_timestamp=current['timestamp'] if 'timestamp' in current else datetime.now(),
            entry_price=entry_price,
            stop_loss_price=round(stop_loss_price, 4),
            take_profit_price=round(take_profit_price, 4),
            risk_reward_ratio=round(risk_reward_ratio, 2),
            confidence=round(confidence, 4),
            quality_tier=quality_tier,
            positive_days=reversal_metrics['positive_days'],
            rsi_improvement=round(reversal_metrics['rsi_improvement'], 2),
            rsi_low=round(rsi_low, 2),
            rsi_current=round(rsi_current, 2),
            macd_improving=reversal_metrics['macd_improving'],
            atr=round(atr, 4),
            crossed_ema_20=crossed_ema_20,
            sector=sector
        )

        self.logger.info(
            f"{ticker}: TREND REVERSAL SIGNAL - Entry: ${entry_price:.2f}, "
            f"RSI: {rsi_low:.0f} -> {rsi_current:.0f}, "
            f"{reversal_metrics['positive_days']}/{self.confirmation_days} days positive"
        )

        return signal

    def _check_prior_downtrend(
        self,
        prior_df: pd.DataFrame
    ) -> tuple:
        """
        Check if stock was in downtrend before confirmation period.

        Returns:
            Tuple of (was_in_downtrend, lowest_rsi)
        """
        if prior_df.empty or len(prior_df) < 2:
            return False, 50.0

        was_in_downtrend = False
        lowest_rsi = 100.0

        for _, row in prior_df.iterrows():
            # Track lowest RSI
            rsi = float(row['rsi']) if pd.notna(row['rsi']) else 50.0
            if rsi < lowest_rsi:
                lowest_rsi = rsi

            # Check for oversold RSI
            if rsi < self.RSI_WAS_OVERSOLD_THRESHOLD:
                was_in_downtrend = True

            # Check if price was below EMA-20
            if pd.notna(row.get('ema_20')):
                pct_from_ema = ((row['close'] - row['ema_20']) / row['ema_20']) * 100
                if pct_from_ema < self.PRICE_BELOW_EMA20_PCT:
                    was_in_downtrend = True

        return was_in_downtrend, lowest_rsi

    def _calculate_reversal_metrics(
        self,
        confirmation_df: pd.DataFrame,
        rsi_low: float
    ) -> Dict[str, Any]:
        """Calculate reversal strength metrics over confirmation window."""

        metrics = {
            'positive_days': 0,
            'rsi_improvement': 0,
            'macd_improving': False,
            'passes': False
        }

        if confirmation_df.empty:
            return metrics

        # Count positive days
        for _, row in confirmation_df.iterrows():
            if pd.notna(row.get('open')) and pd.notna(row['close']):
                if row['close'] > row['open']:
                    metrics['positive_days'] += 1

        # RSI improvement from low
        current_rsi = float(confirmation_df.iloc[-1]['rsi']) if pd.notna(confirmation_df.iloc[-1]['rsi']) else 50
        metrics['rsi_improvement'] = current_rsi - rsi_low

        # MACD histogram improving
        macd_values = [
            float(row['macd_histogram'])
            for _, row in confirmation_df.iterrows()
            if pd.notna(row.get('macd_histogram'))
        ]

        if len(macd_values) >= 2:
            # Check if trending up
            macd_improving = True
            for i in range(1, len(macd_values)):
                if macd_values[i] < macd_values[i-1] - 0.01:
                    macd_improving = False
                    break
            # Also count as improving if turned positive
            if len(macd_values) >= 2 and macd_values[-1] > 0 and macd_values[0] < 0:
                macd_improving = True
            metrics['macd_improving'] = macd_improving

        return metrics

    def _passes_reversal_criteria(self, metrics: Dict[str, Any]) -> bool:
        """Check if reversal metrics meet minimum criteria."""

        # Must have minimum positive days
        if metrics['positive_days'] < self.min_positive_days:
            return False

        # RSI must have improved significantly
        if metrics['rsi_improvement'] < self.min_rsi_improvement:
            return False

        # MACD must be improving if required
        if self.require_macd_improving and not metrics['macd_improving']:
            return False

        metrics['passes'] = True
        return True

    def _calculate_confidence(
        self,
        reversal_metrics: Dict[str, Any],
        rsi_low: float,
        crossed_ema_20: bool
    ) -> float:
        """Calculate confidence score for the signal."""
        scores = []

        # 1. Positive Days Score (0-25 points)
        positive_days = reversal_metrics['positive_days']
        if positive_days >= 3:
            days_score = 25
        elif positive_days >= 2:
            days_score = 18
        else:
            days_score = 10
        scores.append(days_score)

        # 2. RSI Improvement Score (0-25 points)
        rsi_improvement = reversal_metrics['rsi_improvement']
        if rsi_improvement >= 20:
            improvement_score = 25
        elif rsi_improvement >= 15:
            improvement_score = 20
        elif rsi_improvement >= 10:
            improvement_score = 15
        else:
            improvement_score = 10
        scores.append(improvement_score)

        # 3. Prior Downtrend Depth Score (0-25 points)
        # Deeper oversold = stronger potential reversal
        if rsi_low <= 25:
            depth_score = 25
        elif rsi_low <= 30:
            depth_score = 22
        elif rsi_low <= 35:
            depth_score = 18
        elif rsi_low <= 40:
            depth_score = 14
        else:
            depth_score = 10
        scores.append(depth_score)

        # 4. Technical Confirmation Score (0-25 points)
        tech_score = 10  # Base score
        if reversal_metrics['macd_improving']:
            tech_score += 10
        if crossed_ema_20:
            tech_score += 5
        scores.append(min(tech_score, 25))

        # Total confidence
        total_score = sum(scores)
        confidence = total_score / 100.0

        return confidence

    def _get_quality_tier(self, confidence: float) -> str:
        """Convert confidence score to quality tier."""
        if confidence >= 0.85:
            return 'A+'
        elif confidence >= 0.70:
            return 'A'
        elif confidence >= 0.55:
            return 'B'
        elif confidence >= 0.40:
            return 'C'
        else:
            return 'D'

    def get_config(self) -> Dict[str, Any]:
        """Return strategy configuration for logging."""
        return {
            'strategy_name': 'TREND_REVERSAL',
            'stop_atr_mult': self.stop_atr_mult,
            'take_profit_rr': self.take_profit_rr,
            'confirmation_days': self.confirmation_days,
            'min_positive_days': self.min_positive_days,
            'min_rsi_improvement': self.min_rsi_improvement,
            'rsi_now_min': self.rsi_now_min,
            'rsi_now_max': self.rsi_now_max,
            'min_confidence': self.min_confidence,
        }
