#!/usr/bin/env python3
"""
Calculate optimal per-pair SL/TP values based on ATR analysis.

This script analyzes historical ATR data to determine pair-specific
stop loss and take profit values optimized for scalping.

Formula:
- SL = ATR × 1.8 (provides protection against normal volatility)
- TP = SL × 2.5 (maintains 2.5:1 reward:risk ratio)
"""

import psycopg2
from typing import Dict, Tuple
import json

# Database connection
DB_CONFIG = {
    'host': 'postgres',  # Docker container name
    'port': 5432,
    'dbname': 'forex',
    'user': 'postgres',
    'password': 'postgres'
}

# Scalping optimization parameters
ATR_MULTIPLIER_SL = 1.8  # Conservative: protects against 1.8× normal volatility
RR_RATIO = 2.5           # 2.5:1 reward:risk ratio for scalping

# JPY pair conversion (2 decimal places vs 4)
JPY_PAIRS = ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY']


def get_atr_data() -> Dict[str, Dict]:
    """
    Query ATR statistics from alert_history.

    Returns:
        Dict mapping epic to ATR statistics
    """
    conn = psycopg2.connect(**DB_CONFIG)
    cur = conn.cursor()

    query = """
    SELECT
        epic,
        pair,
        AVG(atr) as avg_atr,
        MIN(atr) as min_atr,
        MAX(atr) as max_atr,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY atr) as median_atr,
        STDDEV(atr) as stddev_atr,
        COUNT(*) as sample_count
    FROM alert_history
    WHERE
        atr IS NOT NULL
        AND atr > 0
    GROUP BY epic, pair
    ORDER BY pair;
    """

    cur.execute(query)
    results = {}

    for row in cur.fetchall():
        epic, pair, avg_atr, min_atr, max_atr, median_atr, stddev_atr, sample_count = row

        # Convert ATR to pips
        if any(jpy in pair for jpy in JPY_PAIRS):
            # JPY pairs: 2 decimal places (0.01 = 1 pip)
            pip_divisor = 0.01
        else:
            # Other pairs: 4 decimal places (0.0001 = 1 pip)
            pip_divisor = 0.0001

        results[epic] = {
            'pair': pair,
            'avg_atr_pips': float(avg_atr) / pip_divisor,
            'min_atr_pips': float(min_atr) / pip_divisor,
            'max_atr_pips': float(max_atr) / pip_divisor,
            'median_atr_pips': float(median_atr) / pip_divisor,
            'stddev_atr_pips': float(stddev_atr) / pip_divisor if stddev_atr else 0,
            'sample_count': sample_count
        }

    cur.close()
    conn.close()

    return results


def calculate_optimal_sltp(atr_stats: Dict) -> Dict[str, Tuple[float, float]]:
    """
    Calculate optimal SL/TP for each pair based on ATR.

    Args:
        atr_stats: Dictionary of ATR statistics per epic

    Returns:
        Dictionary mapping epic to (optimal_sl, optimal_tp) tuple
    """
    results = {}

    print("\n" + "="*80)
    print("PER-PAIR OPTIMAL SL/TP CALCULATION (ATR-Based)")
    print("="*80)
    print(f"Method: SL = ATR × {ATR_MULTIPLIER_SL}, TP = SL × {RR_RATIO}")
    print(f"Data: Historical signals from alert_history table")
    print("="*80 + "\n")

    for epic, stats in sorted(atr_stats.items(), key=lambda x: x[1]['pair']):
        pair = stats['pair']
        avg_atr = stats['avg_atr_pips']
        median_atr = stats['median_atr_pips']
        sample_count = stats['sample_count']

        # Use median ATR (more robust to outliers)
        base_atr = median_atr

        # Calculate optimal SL/TP
        optimal_sl = round(base_atr * ATR_MULTIPLIER_SL, 1)
        optimal_tp = round(optimal_sl * RR_RATIO, 1)

        # Enforce minimum values for scalping
        optimal_sl = max(optimal_sl, 5.0)  # Minimum 5 pips SL
        optimal_tp = max(optimal_tp, 10.0) # Minimum 10 pips TP

        results[epic] = (optimal_sl, optimal_tp)

        print(f"{pair:8} ({epic})")
        print(f"  ATR: Median={median_atr:.1f} pips, Avg={avg_atr:.1f} pips (n={sample_count})")
        print(f"  → Optimal SL: {optimal_sl:.1f} pips")
        print(f"  → Optimal TP: {optimal_tp:.1f} pips")
        print(f"  → Risk:Reward: 1:{RR_RATIO}")
        print()

    return results


def generate_sql_update(optimal_values: Dict[str, Tuple[float, float]]) -> str:
    """
    Generate SQL to update smc_simple_pair_overrides with optimal values.

    Args:
        optimal_values: Dictionary mapping epic to (sl, tp) tuple

    Returns:
        SQL UPDATE statements
    """
    sql_statements = []

    sql_statements.append("-- Update per-pair scalp SL/TP based on ATR analysis")
    sql_statements.append("-- Generated by calculate_optimal_sltp.py\n")

    for epic, (sl, tp) in sorted(optimal_values.items()):
        sql = f"""UPDATE smc_simple_pair_overrides
SET scalp_sl_pips = {sl}, scalp_tp_pips = {tp}
WHERE epic = '{epic}';"""
        sql_statements.append(sql)

    return "\n".join(sql_statements)


def main():
    """Main execution."""
    print("Fetching ATR data from database...")
    atr_stats = get_atr_data()

    if not atr_stats:
        print("❌ No ATR data found in alert_history table!")
        print("   Run the scanner to generate signals first.")
        return

    print(f"✅ Found ATR data for {len(atr_stats)} pairs\n")

    # Calculate optimal values
    optimal_values = calculate_optimal_sltp(atr_stats)

    # Generate SQL
    print("\n" + "="*80)
    print("SQL UPDATE STATEMENTS")
    print("="*80 + "\n")

    sql = generate_sql_update(optimal_values)
    print(sql)

    # Save to file
    output_file = '/app/forex_scanner/scripts/update_scalp_sltp.sql'
    with open(output_file, 'w') as f:
        f.write(sql)

    print("\n" + "="*80)
    print(f"✅ SQL saved to: {output_file}")
    print("="*80)
    print("\nTo apply these values:")
    print("  1. Review the SQL statements above")
    print(f"  2. docker exec postgres psql -U postgres -d strategy_config -f {output_file}")
    print("  3. Restart task-worker: docker restart task-worker")
    print()

    # Summary statistics
    print("="*80)
    print("SUMMARY STATISTICS")
    print("="*80)

    sl_values = [v[0] for v in optimal_values.values()]
    tp_values = [v[1] for v in optimal_values.values()]

    print(f"Stop Loss Range:   {min(sl_values):.1f} - {max(sl_values):.1f} pips (avg: {sum(sl_values)/len(sl_values):.1f})")
    print(f"Take Profit Range: {min(tp_values):.1f} - {max(tp_values):.1f} pips (avg: {sum(tp_values)/len(tp_values):.1f})")
    print(f"Risk:Reward Ratio: 1:{RR_RATIO} (consistent across all pairs)")
    print()


if __name__ == '__main__':
    main()
